--- ============================ HEADER ============================
--[[
    Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)
    Author: NextActionGuide Team
    Date: 30/09/2024
]]

--- ======= LOCALIZE =======
-- Addon
local addonName, ns = ...
---@class NAG
local NAG = LibStub("AceAddon-3.0"):GetAddon("NAG")
local L = LibStub("AceLocale-3.0"):GetLocale("NAG", true)
ns.assertType(L, "table", "L")

-- Core Modules
local APLSchema = ns.APLSchema
local APL = NAG:GetModule("APL")

-- WoW API
local GetSpellCooldown = ns.GetSpellCooldownUnified
local GetSpellCharges = ns.GetSpellChargesUnified
local GetSpellInfo = ns.GetSpellInfoUnified
local UnitAura = ns.UnitAuraUnified
local UnitBuff = ns.UnitBuffUnified
local UnitDebuff = ns.UnitDebuffUnified
local IsSpellInRange = ns.IsSpellInRangeUnified
local UnitHealth = ns.UnitHealthUnified
local UnitHealthMax = ns.UnitHealthMaxUnified
local UnitPower = ns.UnitPowerUnified
local UnitPowerMax = ns.UnitPowerMaxUnified
local GetTime = GetTime

-- Lua Functions
local format = format or string.format
local floor = floor or math.floor
local ceil = ceil or math.ceil
local min = min or math.min
local max = max or math.max
local abs = abs or math.abs
local pairs = pairs
local ipairs = ipairs
local type = type
local tonumber = tonumber
local tinsert = tinsert
local tremove = tremove
local wipe = wipe

-- Debug
local DEBUG = false

--- ============================ CONTENT ============================
---@class APLEngine: ModuleBase
local APLEngine = NAG:CreateModule("APLEngine", nil, {
    moduleType = ns.MODULE_TYPES.CORE,
    optionsOrder = 15,
})

-- Constants
local UNIT_SELF = "player"
local UNIT_TARGET = "target"
local UNIT_FOCUS = "focus"
local UNIT_PET = "pet"
local MAX_TARGETS = 10
local DEFAULT_REACTION_TIME = 0.25 -- seconds
local DEFAULT_INPUT_DELAY = 0.25 -- seconds

-- State tracking
local engineState = {
    currentAPL = nil,
    lastSuggestedAction = nil,
    prepullTimer = 0,
    inPrepull = false,
    combatTime = 0,
    playerState = {
        health = 0,
        healthMax = 0,
        healthPercent = 0,
        mana = 0,
        manaMax = 0,
        manaPercent = 0,
        rage = 0,
        energy = 0,
        comboPoints = 0,
        focus = 0,
        runicPower = 0,
        solarEnergy = 0,
        lunarEnergy = 0,
        holyPower = 0,
        auras = {},
        cooldowns = {},
        isMoving = false,
        gcdEndTime = 0,
    },
    targetState = {
        exists = false,
        health = 0,
        healthMax = 0,
        healthPercent = 0,
        auras = {},
        dots = {},
        isExecutePhase = false,
    },
    sequences = {},
    channeling = nil,
}

-- Module initialization
function APLEngine:ModuleInitialize()
    self:RegisterMessage("NAG_COMBAT_START", "OnCombatStart")
    self:RegisterMessage("NAG_COMBAT_END", "OnCombatEnd")
    self:RegisterMessage("NAG_PREPULL_START", "OnPrepullStart")
    self:RegisterMessage("NAG_PREPULL_END", "OnPrepullEnd")
    self:RegisterMessage("NAG_APL_LOADED", "OnAPLLoaded")
    
    -- Register for game events
    self:RegisterEvent("UNIT_HEALTH", "UpdateUnitHealth")
    self:RegisterEvent("UNIT_POWER_UPDATE", "UpdateUnitPower")
    self:RegisterEvent("UNIT_AURA", "UpdateUnitAuras")
    self:RegisterEvent("PLAYER_TARGET_CHANGED", "UpdateTargetState")
    self:RegisterEvent("SPELL_UPDATE_COOLDOWN", "UpdateCooldowns")
    self:RegisterEvent("UNIT_SPELLCAST_SUCCEEDED", "OnSpellCastSucceeded")
    self:RegisterEvent("UNIT_SPELLCAST_CHANNEL_START", "OnChannelStart")
    self:RegisterEvent("UNIT_SPELLCAST_CHANNEL_STOP", "OnChannelStop")
    
    self:ScheduleRepeatingTimer("UpdateEngineState", 0.1) -- Update state every 100ms
    self:ScheduleRepeatingTimer("EvaluateCurrentAPL", 0.1) -- Evaluate APL every 100ms
end

-- Event handlers
function APLEngine:OnCombatStart()
    engineState.inPrepull = false
    engineState.combatTime = 0
    wipe(engineState.sequences)
    self:UpdateEngineState()
end

function APLEngine:OnCombatEnd()
    engineState.combatTime = 0
    wipe(engineState.sequences)
    engineState.channeling = nil
    engineState.lastSuggestedAction = nil
end

function APLEngine:OnPrepullStart(event, timer)
    engineState.inPrepull = true
    engineState.prepullTimer = timer
    wipe(engineState.sequences)
end

function APLEngine:OnPrepullEnd()
    engineState.inPrepull = false
    engineState.prepullTimer = 0
end

function APLEngine:OnAPLLoaded(event, apl)
    engineState.currentAPL = apl
    wipe(engineState.sequences)
    self:UpdateEngineState()
    self:EvaluateCurrentAPL()
end

function APLEngine:UpdateUnitHealth(event, unit)
    if unit == UNIT_SELF then
        self:UpdatePlayerHealth()
    elseif unit == UNIT_TARGET then
        self:UpdateTargetHealth()
    end
end

function APLEngine:UpdateUnitPower(event, unit, powerType)
    if unit == UNIT_SELF then
        self:UpdatePlayerResources()
    end
end

function APLEngine:UpdateUnitAuras(event, unit)
    if unit == UNIT_SELF then
        self:UpdatePlayerAuras()
    elseif unit == UNIT_TARGET then
        self:UpdateTargetAuras()
    end
end

function APLEngine:UpdateTargetState()
    self:UpdateTargetHealth()
    self:UpdateTargetAuras()
end

function APLEngine:OnSpellCastSucceeded(event, unit, _, spellID)
    if unit == UNIT_SELF then
        -- Update GCD
        local _, gcdDuration = GetSpellCooldown(61304) -- Global Cooldown spell ID
        if gcdDuration > 0 then
            engineState.playerState.gcdEndTime = GetTime() + gcdDuration
        end
        
        -- Update cooldowns for this spell
        self:UpdateCooldowns()
    end
end

function APLEngine:OnChannelStart(event, unit, _, spellID)
    if unit == UNIT_SELF then
        local spellName = GetSpellInfo(spellID)
        engineState.channeling = {
            spellId = spellID,
            spellName = spellName,
            startTime = GetTime(),
            ticks = 0
        }
    end
end

function APLEngine:OnChannelStop(event, unit)
    if unit == UNIT_SELF then
        engineState.channeling = nil
    end
end

-- State update functions
function APLEngine:UpdateEngineState()
    -- Update time tracking
    if engineState.inPrepull then
        engineState.prepullTimer = engineState.prepullTimer - 0.1
        if engineState.prepullTimer <= 0 then
            self:FireMessage("NAG_PREPULL_END")
        end
    elseif UnitAffectingCombat(UNIT_SELF) then
        engineState.combatTime = engineState.combatTime + 0.1
    end
    
    -- Update all states using APL Values
    self:UpdateAllStates()
end

function APLEngine:UpdateAllStates()
    -- Use APL Values for all state updates
    local state = engineState.playerState
    
    -- Health/Resources using APL Values
    state.health = APL.Values.CurrentHealth(UNIT_SELF)
    state.healthMax = UnitHealthMax(UNIT_SELF)
    state.healthPercent = APL.Values.CurrentHealthPercent(UNIT_SELF)
    state.mana = APL.Values.CurrentMana(UNIT_SELF)
    state.manaMax = UnitPowerMax(UNIT_SELF, Enum.PowerType.Mana)
    state.manaPercent = APL.Values.CurrentManaPercent(UNIT_SELF)
    
    -- Class Resources
    state.rage = APL.Values.CurrentRage()
    state.energy = APL.Values.CurrentEnergy()
    state.comboPoints = APL.Values.CurrentComboPoints()
    state.focus = APL.Values.CurrentFocus()
    state.runicPower = APL.Values.CurrentRunicPower()
    
    -- Class-specific resources
    local _, class = UnitClass(UNIT_SELF)
    if class == "DRUID" then
        state.lunarEnergy = APL.Values.CurrentLunarEnergy()
        state.solarEnergy = APL.Values.CurrentSolarEnergy()
    elseif class == "PALADIN" then
        state.holyPower = APL.Values.CurrentHolyPower()
    end
    
    -- Target state
    local targetState = engineState.targetState
    targetState.exists = UnitExists(UNIT_TARGET)
    if targetState.exists then
        targetState.health = APL.Values.CurrentHealth(UNIT_TARGET)
        targetState.healthMax = UnitHealthMax(UNIT_TARGET)
        targetState.healthPercent = APL.Values.CurrentHealthPercent(UNIT_TARGET)
    end
    
    -- Movement and GCD
    state.isMoving = APL.Values.UnitIsMoving(UNIT_SELF)
    state.gcdEndTime = GetTime() + (not APL.Values.GCDIsReady() and APL.Values.GCDTimeToReady() or 0)
    
    -- Update auras and cooldowns using existing functions since they're more complex
    self:UpdatePlayerAuras()
    self:UpdateTargetAuras()
    self:UpdateCooldowns()
end

function APLEngine:UpdatePlayerHealth()
    engineState.playerState.health = UnitHealth(UNIT_SELF)
    engineState.playerState.healthMax = UnitHealthMax(UNIT_SELF)
    engineState.playerState.healthPercent = engineState.playerState.healthMax > 0 
        and (engineState.playerState.health / engineState.playerState.healthMax) * 100 
        or 0
end

function APLEngine:UpdatePlayerResources()
    -- Mana
    engineState.playerState.mana = UnitPower(UNIT_SELF, Enum.PowerType.Mana)
    engineState.playerState.manaMax = UnitPowerMax(UNIT_SELF, Enum.PowerType.Mana)
    engineState.playerState.manaPercent = engineState.playerState.manaMax > 0 
        and (engineState.playerState.mana / engineState.playerState.manaMax) * 100 
        or 0
    
    -- Class-specific resources
    engineState.playerState.rage = UnitPower(UNIT_SELF, Enum.PowerType.Rage)
    engineState.playerState.energy = UnitPower(UNIT_SELF, Enum.PowerType.Energy)
    engineState.playerState.comboPoints = UnitPower(UNIT_SELF, Enum.PowerType.ComboPoints)
    engineState.playerState.focus = UnitPower(UNIT_SELF, Enum.PowerType.Focus)
    engineState.playerState.runicPower = UnitPower(UNIT_SELF, Enum.PowerType.RunicPower)
    
    -- Class-specific resources that don't exist in all WoW versions
    local _, class = UnitClass(UNIT_SELF)
    if class == "DRUID" then
        -- Check if lunar/solar energy exists in this version
        local eclipseBar = GetEclipseDirection and GetEclipseDirection() or nil
        if eclipseBar then
            -- Logic for lunar/solar energy for Druid eclipse
            engineState.playerState.lunarEnergy = UnitPower(UNIT_SELF, Enum.PowerType.LunarPower or 8)
            engineState.playerState.solarEnergy = 100 - engineState.playerState.lunarEnergy
        end
    elseif class == "PALADIN" then
        -- Check if holy power exists in this version
        engineState.playerState.holyPower = UnitPower(UNIT_SELF, Enum.PowerType.HolyPower or 9)
    end
end

function APLEngine:UpdatePlayerAuras()
    wipe(engineState.playerState.auras)
    
    -- Get all auras on player
    for i = 1, 40 do
        local name, icon, count, _, duration, expirationTime, source, _, _, spellId = UnitAura(UNIT_SELF, i, "HELPFUL")
        if not name then break end
        
        engineState.playerState.auras[spellId] = {
            name = name,
            icon = icon,
            count = count,
            duration = duration,
            expirationTime = expirationTime,
            source = source,
            remaining = expirationTime > 0 and (expirationTime - GetTime()) or 0
        }
    end
    
    for i = 1, 40 do
        local name, icon, count, _, duration, expirationTime, source, _, _, spellId = UnitAura(UNIT_SELF, i, "HARMFUL")
        if not name then break end
        
        engineState.playerState.auras[spellId] = {
            name = name,
            icon = icon,
            count = count,
            duration = duration,
            expirationTime = expirationTime,
            source = source,
            remaining = expirationTime > 0 and (expirationTime - GetTime()) or 0
        }
    end
end

function APLEngine:UpdateTargetHealth()
    engineState.targetState.exists = UnitExists(UNIT_TARGET)
    if engineState.targetState.exists then
        engineState.targetState.health = UnitHealth(UNIT_TARGET)
        engineState.targetState.healthMax = UnitHealthMax(UNIT_TARGET)
        engineState.targetState.healthPercent = engineState.targetState.healthMax > 0 
            and (engineState.targetState.health / engineState.targetState.healthMax) * 100 
            or 0
            
        -- Check execute phase
        -- This is a simplified check - real implementation would consider class-specific thresholds
        engineState.targetState.isExecutePhase = engineState.targetState.healthPercent <= 20
    else
        engineState.targetState.health = 0
        engineState.targetState.healthMax = 0
        engineState.targetState.healthPercent = 0
        engineState.targetState.isExecutePhase = false
    end
end

function APLEngine:UpdateTargetAuras()
    wipe(engineState.targetState.auras)
    wipe(engineState.targetState.dots)
    
    if not engineState.targetState.exists then return end
    
    -- Get all auras on target
    for i = 1, 40 do
        local name, icon, count, _, duration, expirationTime, source, _, _, spellId = UnitAura(UNIT_TARGET, i, "HELPFUL")
        if not name then break end
        
        engineState.targetState.auras[spellId] = {
            name = name,
            icon = icon,
            count = count,
            duration = duration,
            expirationTime = expirationTime,
            source = source,
            remaining = expirationTime > 0 and (expirationTime - GetTime()) or 0
        }
    end
    
    for i = 1, 40 do
        local name, icon, count, debuffType, duration, expirationTime, source, _, _, spellId = UnitAura(UNIT_TARGET, i, "HARMFUL")
        if not name then break end
        
        engineState.targetState.auras[spellId] = {
            name = name,
            icon = icon,
            count = count,
            debuffType = debuffType,
            duration = duration,
            expirationTime = expirationTime,
            source = source,
            remaining = expirationTime > 0 and (expirationTime - GetTime()) or 0
        }
        
        -- If cast by player, consider it a DoT
        if source == UNIT_SELF then
            engineState.targetState.dots[spellId] = {
                name = name,
                icon = icon,
                count = count,
                duration = duration,
                expirationTime = expirationTime,
                remaining = expirationTime > 0 and (expirationTime - GetTime()) or 0,
                tickFrequency = 3 -- Default tick frequency, would need spell-specific data
            }
        end
    end
end

function APLEngine:UpdateCooldowns()
    wipe(engineState.playerState.cooldowns)
    
    -- This would need to be populated with all relevant spells from the APL
    -- For simplicity, we'll just add example logic
    if engineState.currentAPL then
        -- Extract all spell IDs from the APL
        local spellIds = self:ExtractSpellIdsFromAPL(engineState.currentAPL)
        
        -- Update cooldowns for all these spells
        for _, spellId in ipairs(spellIds) do
            local start, duration, enabled = GetSpellCooldown(spellId)
            if start and duration then
                local cdRemaining = 0
                if start > 0 and duration > 0 then
                    cdRemaining = start + duration - GetTime()
                    if cdRemaining < 0 then cdRemaining = 0 end
                end
                
                local charges, maxCharges, chargeStart, chargeDuration = GetSpellCharges(spellId)
                
                engineState.playerState.cooldowns[spellId] = {
                    start = start,
                    duration = duration,
                    enabled = enabled == 1,
                    charges = charges or 0,
                    maxCharges = maxCharges or 0,
                    remaining = cdRemaining,
                    isReady = (cdRemaining <= 0 and enabled == 1) or (charges and charges > 0)
                }
            end
        end
    end
end

-- APL Evaluation
function APLEngine:EvaluateCurrentAPL()
    if not engineState.currentAPL then return end
    
    local suggestedAction = nil
    
    if engineState.inPrepull and engineState.currentAPL.prepullActions then
        suggestedAction = self:EvaluatePrepullActions(engineState.currentAPL.prepullActions)
    else
        suggestedAction = self:EvaluatePriorityList(engineState.currentAPL.priorityList)
    end
    
    if suggestedAction and suggestedAction ~= engineState.lastSuggestedAction then
        engineState.lastSuggestedAction = suggestedAction
        NAG:SuggestAction(suggestedAction)
    end
end

function APLEngine:EvaluatePrepullActions(prepullActions)
    if not prepullActions or #prepullActions == 0 then return nil end
    
    for _, action in ipairs(prepullActions) do
        if action.doAtValue and self:EvaluateValue(action.doAtValue) <= engineState.prepullTimer then
            return self:ProcessAction(action)
        end
    end
    
    return nil
end

function APLEngine:EvaluatePriorityList(priorityList)
    if not priorityList or #priorityList == 0 then return nil end
    
    for _, action in ipairs(priorityList) do
        if not action.condition or self:EvaluateCondition(action.condition) then
            return self:ProcessAction(action)
        end
    end
    
    return nil
end

function APLEngine:ProcessAction(action)
    if not action or not action.action then return nil end
    
    -- Use APL Actions system
    local actionType = action.action
    local actionFunc = APL.Actions[actionType]
    
    if actionFunc then
        -- Convert action parameters to match APL system
        local result = actionFunc(action)
        if result then
            return {
                type = result.type or "spell",
                id = result.id,
                target = result.target,
                isChannel = result.isChannel,
                isFriendly = result.isFriendly
            }
        end
    else
        NAG:Print("Unknown action type: " .. tostring(actionType))
    end
    
    return nil
end

-- Helper functions
function APLEngine:CanCastSpell(spellId, target)
    if not spellId then return false end
    
    -- Use APL Values system for checks
    return APL.Values.SpellIsKnown(spellId) and 
           APL.Values.SpellCanCast(spellId) and
           APL.Values.GCDIsReady() and
           (target == UNIT_SELF or not UnitExists(target) or IsSpellInRange(GetSpellInfo(spellId), target) ~= 0)
end

function APLEngine:CanProcessAction(action)
    if not action or not action.action then return false end
    
    local actionType = action.action
    
    if actionType == "castSpell" or actionType == "castFriendlySpell" or actionType == "channelSpell" then
        return self:CanCastSpell(action.spellId, action.target)
    end
    
    -- For other action types, assume they're always processable
    return true
end

function APLEngine:ExtractSpellIdsFromAPL(apl)
    local spellIds = {}
    
    -- This would scan through the entire APL structure and extract all spell IDs
    -- For simplicity, we'll just return an empty list
    
    return spellIds
end

-- Value/Condition Evaluation
function APLEngine:EvaluateCondition(condition)
    if not condition then return true end
    
    return self:EvaluateValue(condition)
end

function APLEngine:EvaluateValue(value)
    if not value then return nil end
    
    if type(value) == "number" then
        return value
    elseif type(value) == "boolean" then
        return value
    elseif type(value) == "string" then
        return value
    end
    
    -- For complex values, check the type
    local valueType = value.valueType
    local valueHandler = self["EvaluateValue_" .. valueType]
    
    if valueHandler then
        return valueHandler(self, value)
    else
        NAG:Print("Unknown value type: " .. tostring(valueType))
        return nil
    end
end

-- Value type handlers
function APLEngine:EvaluateValue_const(value)
    return value.val
end

function APLEngine:EvaluateValue_and(value)
    if not value.vals or #value.vals == 0 then return false end
    
    for _, subValue in ipairs(value.vals) do
        if not self:EvaluateValue(subValue) then
            return false
        end
    end
    
    return true
end

function APLEngine:EvaluateValue_or(value)
    if not value.vals or #value.vals == 0 then return false end
    
    for _, subValue in ipairs(value.vals) do
        if self:EvaluateValue(subValue) then
            return true
        end
    end
    
    return false
end

function APLEngine:EvaluateValue_not(value)
    if not value.val then return true end
    
    return not self:EvaluateValue(value.val)
end

function APLEngine:EvaluateValue_cmp(value)
    if not value.lhs or not value.rhs or not value.op then return false end
    
    local lhs = self:EvaluateValue(value.lhs)
    local rhs = self:EvaluateValue(value.rhs)
    
    if lhs == nil or rhs == nil then return false end
    
    if value.op == APLSchema.ComparisonOperator.Eq then
        return lhs == rhs
    elseif value.op == APLSchema.ComparisonOperator.Ne then
        return lhs ~= rhs
    elseif value.op == APLSchema.ComparisonOperator.Lt then
        return lhs < rhs
    elseif value.op == APLSchema.ComparisonOperator.Le then
        return lhs <= rhs
    elseif value.op == APLSchema.ComparisonOperator.Gt then
        return lhs > rhs
    elseif value.op == APLSchema.ComparisonOperator.Ge then
        return lhs >= rhs
    end
    
    return false
end

function APLEngine:EvaluateValue_math(value)
    if not value.lhs or not value.rhs or not value.op then return 0 end
    
    local lhs = self:EvaluateValue(value.lhs)
    local rhs = self:EvaluateValue(value.rhs)
    
    if lhs == nil or rhs == nil then return 0 end
    
    if value.op == APLSchema.MathOperator.Add then
        return lhs + rhs
    elseif value.op == APLSchema.MathOperator.Sub then
        return lhs - rhs
    elseif value.op == APLSchema.MathOperator.Mul then
        return lhs * rhs
    elseif value.op == APLSchema.MathOperator.Div then
        if rhs == 0 then return 0 end
        return lhs / rhs
    end
    
    return 0
end

function APLEngine:EvaluateValue_max(value)
    if not value.vals or #value.vals == 0 then return 0 end
    
    local maxVal = -math.huge
    
    for _, subValue in ipairs(value.vals) do
        local val = self:EvaluateValue(subValue)
        maxVal = max(maxVal, val or 0)
    end
    
    return maxVal
end

function APLEngine:EvaluateValue_min(value)
    if not value.vals or #value.vals == 0 then return 0 end
    
    local minVal = math.huge
    
    for _, subValue in ipairs(value.vals) do
        local val = self:EvaluateValue(subValue)
        minVal = min(minVal, val or 0)
    end
    
    return minVal
end

-- Resource values
function APLEngine:EvaluateValue_currentHealth(value)
    local sourceUnit = value.sourceUnit or UNIT_SELF
    
    if sourceUnit == UNIT_SELF then
        return engineState.playerState.health
    elseif sourceUnit == UNIT_TARGET then
        return engineState.targetState.health
    end
    
    return 0
end

function APLEngine:EvaluateValue_currentHealthPercent(value)
    local sourceUnit = value.sourceUnit or UNIT_SELF
    
    if sourceUnit == UNIT_SELF then
        return engineState.playerState.healthPercent
    elseif sourceUnit == UNIT_TARGET then
        return engineState.targetState.healthPercent
    end
    
    return 0
end

function APLEngine:EvaluateValue_currentMana(value)
    local sourceUnit = value.sourceUnit or UNIT_SELF
    
    if sourceUnit == UNIT_SELF then
        return engineState.playerState.mana
    end
    
    return 0
end

function APLEngine:EvaluateValue_currentManaPercent(value)
    local sourceUnit = value.sourceUnit or UNIT_SELF
    
    if sourceUnit == UNIT_SELF then
        return engineState.playerState.manaPercent
    end
    
    return 0
end

function APLEngine:EvaluateValue_currentRage(value)
    return engineState.playerState.rage
end

function APLEngine:EvaluateValue_currentEnergy(value)
    return engineState.playerState.energy
end

function APLEngine:EvaluateValue_currentComboPoints(value)
    return engineState.playerState.comboPoints
end

-- GCD values
function APLEngine:EvaluateValue_gcdIsReady(value)
    return GetTime() >= engineState.playerState.gcdEndTime
end

function APLEngine:EvaluateValue_gcdTimeToReady(value)
    local remaining = engineState.playerState.gcdEndTime - GetTime()
    return max(0, remaining)
end

-- Spell values
function APLEngine:EvaluateValue_spellIsKnown(value)
    if not value.spellId then return false end
    
    local name = GetSpellInfo(value.spellId)
    return name ~= nil
end

function APLEngine:EvaluateValue_spellCanCast(value)
    if not value.spellId then return false end
    
    return self:CanCastSpell(value.spellId, value.target)
end

function APLEngine:EvaluateValue_spellIsReady(value)
    if not value.spellId then return false end
    
    local cooldown = engineState.playerState.cooldowns[value.spellId]
    return cooldown and cooldown.isReady or false
end

function APLEngine:EvaluateValue_spellTimeToReady(value)
    if not value.spellId then return 0 end
    
    local cooldown = engineState.playerState.cooldowns[value.spellId]
    return cooldown and cooldown.remaining or 0
end

-- Aura values
function APLEngine:EvaluateValue_auraIsActive(value)
    if not value.auraId then return false end
    
    local sourceUnit = value.sourceUnit or UNIT_SELF
    
    if sourceUnit == UNIT_SELF then
        return engineState.playerState.auras[value.auraId] ~= nil
    elseif sourceUnit == UNIT_TARGET then
        return engineState.targetState.auras[value.auraId] ~= nil
    end
    
    return false
end

function APLEngine:EvaluateValue_auraRemainingTime(value)
    if not value.auraId then return 0 end
    
    local sourceUnit = value.sourceUnit or UNIT_SELF
    
    if sourceUnit == UNIT_SELF then
        local aura = engineState.playerState.auras[value.auraId]
        return aura and aura.remaining or 0
    elseif sourceUnit == UNIT_TARGET then
        local aura = engineState.targetState.auras[value.auraId]
        return aura and aura.remaining or 0
    end
    
    return 0
end

function APLEngine:EvaluateValue_auraNumStacks(value)
    if not value.auraId then return 0 end
    
    local sourceUnit = value.sourceUnit or UNIT_SELF
    
    if sourceUnit == UNIT_SELF then
        local aura = engineState.playerState.auras[value.auraId]
        return aura and aura.count or 0
    elseif sourceUnit == UNIT_TARGET then
        local aura = engineState.targetState.auras[value.auraId]
        return aura and aura.count or 0
    end
    
    return 0
end

-- Dot values
function APLEngine:EvaluateValue_dotIsActive(value)
    if not value.spellId then return false end
    
    local targetUnit = value.targetUnit or UNIT_TARGET
    
    if targetUnit == UNIT_TARGET then
        return engineState.targetState.dots[value.spellId] ~= nil
    end
    
    return false
end

function APLEngine:EvaluateValue_dotRemainingTime(value)
    if not value.spellId then return 0 end
    
    local targetUnit = value.targetUnit or UNIT_TARGET
    
    if targetUnit == UNIT_TARGET then
        local dot = engineState.targetState.dots[value.spellId]
        return dot and dot.remaining or 0
    end
    
    return 0
end

function APLEngine:EvaluateValue_dotTickFrequency(value)
    if not value.spellId then return 0 end
    
    local targetUnit = value.targetUnit or UNIT_TARGET
    
    if targetUnit == UNIT_TARGET then
        local dot = engineState.targetState.dots[value.spellId]
        return dot and dot.tickFrequency or 0
    end
    
    return 0
end

-- Encounter values
function APLEngine:EvaluateValue_currentTime(value)
    return engineState.combatTime
end

function APLEngine:EvaluateValue_isExecutePhase(value)
    if not value.threshold then return false end
    
    local threshold = 0
    
    if value.threshold == APLSchema.ExecutePhaseThreshold.E20 then
        threshold = 20
    elseif value.threshold == APLSchema.ExecutePhaseThreshold.E25 then
        threshold = 25
    elseif value.threshold == APLSchema.ExecutePhaseThreshold.E35 then
        threshold = 35
    elseif value.threshold == APLSchema.ExecutePhaseThreshold.E90 then
        threshold = 90
    end
    
    return engineState.targetState.healthPercent <= threshold
end

function APLEngine:EvaluateValue_numberTargets(value)
    -- Simplified - in a real implementation, this would count actual enemies
    return engineState.targetState.exists and 1 or 0
end

-- Sequence values
function APLEngine:EvaluateValue_sequenceIsComplete(value)
    if not value.sequenceName then return false end
    
    local sequence = engineState.sequences[value.sequenceName]
    return sequence and sequence.currentIndex > #sequence.actions or false
end

function APLEngine:EvaluateValue_sequenceIsReady(value)
    if not value.sequenceName then return false end
    
    local sequence = engineState.sequences[value.sequenceName]
    if not sequence or sequence.currentIndex > #sequence.actions then
        return false
    end
    
    local currentAction = sequence.actions[sequence.currentIndex]
    return self:CanProcessAction(currentAction)
end

-- Register the module
NAG.APLEngine = APLEngine 