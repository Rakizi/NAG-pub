--- ============================ HEADER ============================
--[[
    Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)

    This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held
        liable for any damages arising from the use of this software.

    You are free to:
    - Share — copy and redistribute the material in any medium or format
    - Adapt — remix, transform, and build upon the material

    Under the following terms:
    - Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were
        made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or
        your use.
    - NonCommercial — You may not use the material for commercial purposes.

    Full license text: https://creativecommons.org/licenses/by-nc/4.0/legalcode

    Author: Rakizi: farendil2020@gmail.com @rakizi http://discord.gg/ebonhold
    Date: 06/01/2024

    STATUS: Development
    NOTES: Prediction engine for SpellLearner system that predicts optimal future actions
]]

--- ======= LOCALIZE =======
--Addon
local _, ns = ...
--- @class NAG
local NAG = LibStub("AceAddon-3.0"):GetAddon("NAG")
local L = LibStub("AceLocale-3.0"):GetLocale("NAG", true)

-- Embed Ace3 libraries
local AceTimer = LibStub("AceTimer-3.0")

-- Constants
local CONSTANTS = {
    PROCESSING_COOLDOWN = 300,  -- 5 minutes between processing
    MIN_OBSERVATIONS = 15,      -- Minimum observations needed for reliable predictions
    MAX_CONTEXT_SIZE = 3,       -- Maximum number of buffs to consider in context
    CONFIDENCE_THRESHOLD = 0.7, -- Minimum confidence required for predictions
    UPDATE_INTERVAL = 0.1,      -- How often to update predictions
    MAX_RUNES = 6,             -- Maximum number of runes
    TRIM_PERCENTAGE = 0.15,    -- Percentage to trim from top and bottom for median
    MAX_PROCESSED_HISTORY = 10, -- How many processed results to keep
    WEIGHT_DECAY_RATE = 0.1,   -- How much to reduce weight of older data (per processing)
    RUNE_TYPE = {              -- Rune types
        BLOOD = 1,
        FROST = 2,
        UNHOLY = 3,
        DEATH = 4
    },
    THROTTLE_LEVELS = {        -- Adaptive throttling levels
        LOW = 0.5,             -- Low FPS/high system load
        MEDIUM = 0.25,         -- Medium FPS/system load
        HIGH = 0.1             -- High FPS/normal system load (default)
    },
    FPS_THRESHOLDS = {         -- FPS thresholds for throttling
        LOW = 20,              -- Below this FPS, use LOW throttle level
        MEDIUM = 40            -- Below this FPS, use MEDIUM throttle level
    }
}

-- Default settings
local defaults = {
    global = {
        version = 1,
        debugMode = true, -- Force debug mode on by default for testing
        predictionDepth = 3, -- How many actions ahead to predict
        testingMode = true,  -- Enable testing features
        deleteProcessedData = false, -- Don't delete data while testing
        resourceCaps = {}, -- Learned resource caps
        resourceCapHistory = {} -- History of observed resource caps
    },
    char = {
        enabled = true,
        lastProcessedTime = 0,  -- When we last processed spell data
        compiled = {},          -- Compiled spell knowledge
        processedHistory = {},  -- History of processed results
    }
}

---@class PredictionEngine: ModuleBase
local PredictionEngine = NAG:CreateModule("PredictionEngine", defaults, {
    optionsCategory = ns.MODULE_CATEGORIES.FEATURE, -- Move to Features tab
    optionsOrder = 20,
    childGroups = "tree",
})

-- Embed AceTimer
AceTimer:Embed(PredictionEngine)

--- Throttled debug message that limits frequency of identical messages
-- @param message string The message to output
-- @param key string A unique key to identify this message type
-- @param interval number How often this message can appear (in seconds)
function PredictionEngine:ThrottledDebug(message, key, interval)
    if not self:GetGlobal().debugMode then return end
    
    interval = interval or 30 -- Default to 30 seconds between identical messages
    key = key or message -- Use message as key if none provided
    
    -- Initialize throttle tracking table
    self.debugThrottles = self.debugThrottles or {}
    
    local currentTime = GetTime()
    local lastTime = self.debugThrottles[key]
    
    -- Only show message if we haven't seen it recently
    if not lastTime or (currentTime - lastTime > interval) then
        self.debugThrottles[key] = currentTime
        self:Debug(message)
    end
end

do -- Ace3 lifecycle methods
    --- Initialize the module
    function PredictionEngine:ModuleInitialize()
        self:Info("Initializing PredictionEngine")
        
        -- Initialize references to other modules
        self.spellLearner = NAG:GetModule("SpellLearner")
        self.stateManager = NAG:GetModule("SpellLearnerStateManager")
        
        if not self.spellLearner or not self.stateManager then
            self:Error("Failed to initialize required modules!")
            return
        end
        
        -- Register prediction-specific commands
        self:RegisterChatCommand("nagsim", function(input)
            if not input or input == "" then
                self:Debug("Usage: /nagsim spellID")
                return
            end
            
            local spellID = tonumber(input)
            if not spellID then
                self:Debug("Invalid spell ID")
                return
            end
            
            local currentState = self.stateManager:CaptureCurrentState()
            local newState, result = self:SimulateSpellCast(spellID, currentState)
        end)
        
        self:RegisterChatCommand("nagcheck", function(input)
            if not input or input == "" then
                self:Debug("Usage: /nagcheck spellID")
                return
            end
            
            local spellID = tonumber(input)
            if not spellID then
                self:Debug("Invalid spell ID")
                return
            end
            
            local state = self.stateManager:CaptureCurrentState()
            local isUsable, reason = self:IsSpellUsable(spellID, state)
            
            self:Debug("=== Spell Usability Check ===")
            self:Debug(string.format("Spell: %s (ID: %d)", GetSpellInfo(spellID) or "Unknown", spellID))
            self:Debug(string.format("Usable: %s", isUsable and "Yes" or "No"))
            self:Debug(string.format("Reason: %s", reason))
        end)
        
        self:RegisterChatCommand("nagcosts", function(input)
            if input and input ~= "" then
                -- Try to convert input to number for spell ID
                local spellID = tonumber(input)
                if spellID then
                    self:InspectLearnedCosts(spellID)
                else
                    self:Debug("Please provide a valid spell ID")
                end
            else
                -- Show summary of all learned costs
                self:InspectLearnedCosts()
            end
        end)
        
        self:Debug("Required modules initialized successfully")
    end

    --- Enable the module
function PredictionEngine:ModuleEnable()
    self:Debug("Enabling PredictionEngine")
    
    -- Initialize prediction state
    self.state = {
        predictions = {},
        lastUpdate = 0,
        updateInterval = CONSTANTS.UPDATE_INTERVAL,
        currentContext = {},  -- Current buff context
        trackedPredictions = {} -- New tracked predictions table
    }
    
    -- Create prediction chain frames
    self:CreatePredictionFrames()
    
    -- Register update events
    self:RegisterUpdateEvents()
    
    -- Hook into NAG's spell casting to validate predictions
    local originalCast = NAG.Cast
    NAG.Cast = function(self, spellID, ...)
        -- Validate prediction
        if PredictionEngine.state and PredictionEngine.state.trackedPredictions and #PredictionEngine.state.trackedPredictions > 0 then
            local currentState = PredictionEngine.stateManager:CaptureCurrentState()
            if currentState then
                PredictionEngine:ValidatePrediction(spellID, currentState)
            end
        end
        
        -- Call original function
        return originalCast(self, spellID, ...)
    end
    
    -- Register slash command for predictions
    self:RegisterChatCommand("nagpredict", function(input)
        self:UpdatePredictions()
        self:PrintPredictions()
    end)
    
    -- Register slash command to show prediction accuracy
    self:RegisterChatCommand("nagaccuracy", function(input)
        self:ShowPredictionAccuracy()
    end)
end

--- Show prediction accuracy statistics
function PredictionEngine:ShowPredictionAccuracy()
    if not self.state.trackedPredictions or #self.state.trackedPredictions == 0 then
        self:Debug("No predictions have been tracked yet")
        return
    end
    
    local totalPredictions = #self.state.trackedPredictions
    local validatedPredictions = 0
    local correctPredictions = 0
    local totalAccuracy = 0
    
    for _, prediction in ipairs(self.state.trackedPredictions) do
        if prediction.validatedTime then
            validatedPredictions = validatedPredictions + 1
            if prediction.wasCorrect then
                correctPredictions = correctPredictions + 1
            end
            totalAccuracy = totalAccuracy + (prediction.stateAccuracy or 0)
        end
    end
    
    self:Debug("=== Prediction Accuracy Statistics ===")
    self:Debug(format("Total predictions tracked: %d", totalPredictions))
    self:Debug(format("Validated predictions: %d", validatedPredictions))
    if validatedPredictions > 0 then
        self:Debug(format("Correct predictions: %d (%.1f%%)", 
            correctPredictions, (correctPredictions / validatedPredictions * 100)))
        self:Debug(format("Average state accuracy: %.1f%%", 
            (totalAccuracy / validatedPredictions * 100)))
    end
    self:Debug("===================================")
    
    -- Show the last 5 predictions
    self:Debug("Last 5 predictions:")
    local startIndex = math.max(1, #self.state.trackedPredictions - 4)
    for i = startIndex, #self.state.trackedPredictions do
        local prediction = self.state.trackedPredictions[i]
        local spellName = GetSpellInfo(prediction.spellID) or "Unknown"
        
        if prediction.validatedTime then
            self:Debug(format("%d. %s (%s) - Accuracy: %.1f%%", 
                i, 
                spellName, 
                prediction.wasCorrect and "CORRECT" or "INCORRECT",
                (prediction.stateAccuracy or 0) * 100))
        else
            self:Debug(format("%d. %s (Not validated yet)", i, spellName))
        end
    end
end

    --- Disable the module
    function PredictionEngine:ModuleDisable()
        self:Debug("Disabling PredictionEngine")
        
        -- Clear prediction state if it exists
        if self.state and self.state.predictions then
            wipe(self.state.predictions)
        end
    end
end

--- Handle combat end
function PredictionEngine:OnCombatEnd()
    -- Wait 2 seconds after combat ends before processing
    C_Timer.After(2, function()
        self:ProcessSpellDataIfAllowed()
    end)
end

--- Force process data (testing command)
function PredictionEngine:ForceProcessData(spellID)
    if not self:GetGlobal().testingMode then
        self:Debug("Testing mode is disabled")
        return
    end
    
    self:Debug("Forcing data processing...")
    self:ProcessSpellData(true, spellID)  -- true = force processing, optional spellID
end

--- Process spell data if enough time has passed
function PredictionEngine:ProcessSpellDataIfAllowed()
    local currentTime = GetTime()
    local lastProcessed = self:GetChar().lastProcessedTime
    
    -- Check if enough time has passed
    if currentTime - lastProcessed < CONSTANTS.PROCESSING_COOLDOWN then
        self:Debug("Not enough time has passed since last processing")
        return
    end
    
    -- Process the data
    self:ProcessSpellData(false)  -- false = normal processing
    
    -- Update last processed time
    self:GetChar().lastProcessedTime = currentTime
end

--- Process all collected spell data
-- @param force boolean Whether to force processing regardless of sample size
-- @param targetSpellID number Optional spell ID to process only that spell
function PredictionEngine:ProcessSpellData(force, targetSpellID)
    if not self.stateManager.db.global.spellChanges then
        self:Debug("No spell changes to process")
        return
    end
    
    self:Debug("|cFF00FFFF========== Starting Spell Data Processing ==========|r")
    if targetSpellID then
        self:Debug(format("|cFF00FFFFProcessing only spell %d (%s)|r", 
            targetSpellID, GetSpellInfo(targetSpellID) or "Unknown"))
    end
    
    -- Process each spell's data
    for spellID, entries in pairs(self.stateManager.db.global.spellChanges) do
        -- Only process if we're not targeting a specific spell or this is the targeted spell
        if not targetSpellID or spellID == targetSpellID then
            -- Check if we have enough entries or if we're forcing processing
            if #entries >= CONSTANTS.MIN_OBSERVATIONS or force then
                self:Debug(format("|cFF00FFFFProcessing spell %d (%s) with %d entries|r", 
                    spellID, GetSpellInfo(spellID) or "Unknown", #entries))
                
                self:ProcessSpellEntries(spellID, entries)
            else
                self:Debug(format("|cFFFF0000Skipping spell %d - Not enough observations (%d < %d)|r", 
                    spellID, #entries, CONSTANTS.MIN_OBSERVATIONS))
            end
        end
    end
    
    -- Clear processed data if not in testing mode and no specific spell was targeted
    if not targetSpellID and not self:GetGlobal().testingMode and self:GetGlobal().deleteProcessedData then
        wipe(self.stateManager.db.global.spellChanges)
        self:Debug("|cFF00FFFFCleared processed data|r")
    end
    
    self:Debug("|cFF00FFFF========== Spell Data Processing Complete ==========|r")
end

-- Add new statistical analysis functions at the top level
local function calculateMean(values)
    local sum = 0
    local count = 0
    for _, v in pairs(values) do
        -- Handle both direct numeric values and table structures
        local value = type(v) == "table" and (v.value or (v.power and v.power.delta)) or v
        if type(value) == "number" then
            sum = sum + value
            count = count + 1
        end
    end
    return count > 0 and sum / count or 0
end

local function calculateStandardDeviation(values, mean)
    local sum = 0
    local count = 0
    for _, v in pairs(values) do
        -- Handle both direct numeric values and table structures
        local value = type(v) == "table" and (v.value or (v.power and v.power.delta)) or v
        if type(value) == "number" then
            sum = sum + (value - mean) ^ 2
            count = count + 1
        end
    end
    return count > 0 and math.sqrt(sum / count) or 0
end

local function isOutlier(value, mean, stdDev, threshold)
    -- Handle both direct numeric values and table structures
    local numValue = type(value) == "table" and (value.value or (value.power and value.power.delta)) or value
    if not numValue or type(numValue) ~= "number" or not mean or not stdDev then return false end
    local zScore = math.abs(numValue - mean) / stdDev
    return zScore > threshold
end

local function analyzeOutliers(entries, field, threshold, currentSpellId)
    -- Debug the input
    NAG:Debug(format("Analyzing %d entries for outliers in field '%s' (minimum %d observations required)", 
        #entries, field, CONSTANTS.MIN_OBSERVATIONS))
    
    -- Validate input
    if not entries or #entries == 0 then
        NAG:Debug("No entries to analyze")
        return {}, {}, { mean = 0, stdDev = 0, sampleSize = 0 }
    end
    
    if not currentSpellId then
        NAG:Debug("Warning: No spellId provided for outlier analysis")
    end
    
    local values = {}
    local valuesBySpellId = {}
    
    -- First pass: Group values by spell ID and extract values
    for _, entry in ipairs(entries) do
        if entry.changes and entry.changes[field] then
            -- Handle different resource change structures
            local value
            -- Use the provided spellId if entry doesn't have one
            local spellId = entry.spellId or currentSpellId
            
            if not spellId then
                NAG:Debug("Warning: Entry missing spellId, using current context")
            end
            
            if field == "resources" then
                -- For resources, we need to handle the power/secondary structure
                if entry.changes[field].power then
                    value = entry.changes[field].power.delta
                elseif entry.changes[field].secondary then
                    value = entry.changes[field].secondary.delta
                end
            else
                value = entry.changes[field]
            end
            
            if type(value) == "number" then
                -- Track values both globally and per spell
                table.insert(values, value)
                
                -- If we don't have a spellId, group everything together
                local groupKey = spellId or "unknown"
                valuesBySpellId[groupKey] = valuesBySpellId[groupKey] or {}
                table.insert(valuesBySpellId[groupKey], {
                    value = value,
                    entry = entry
                })
            end
        end
    end
    
    -- Debug value distribution
    NAG:Debug("Value distribution:")
    for groupKey, spellValues in pairs(valuesBySpellId) do
        local spellName = groupKey ~= "unknown" and GetSpellInfo(groupKey) or "Unknown"
        NAG:Debug(format("  %s: %d values", 
            groupKey ~= "unknown" and format("Spell %d (%s)", groupKey, spellName) or "Unknown spell",
            #spellValues))
        
        -- Calculate mean and stddev per spell
        local sum = 0
        for _, v in ipairs(spellValues) do
            sum = sum + v.value
        end
        local mean = #spellValues > 0 and sum / #spellValues or 0
        
        local sumSq = 0
        for _, v in ipairs(spellValues) do
            sumSq = sumSq + (v.value - mean)^2
        end
        local stdDev = #spellValues > 0 and math.sqrt(sumSq / #spellValues) or 0
        
        NAG:Debug(format("    Mean: %.2f, StdDev: %.2f", mean, stdDev))
    end
    
    -- Identify outliers per spell ID
    local outliers = {}
    local validEntries = {}
    
    for _, entry in ipairs(entries) do
        local spellId = entry.spellId or currentSpellId
        local groupKey = spellId or "unknown"
        local spellValues = valuesBySpellId[groupKey]
        
        -- Only process if we have enough samples (use same threshold as ProcessSpellData)
        if spellValues and #spellValues >= CONSTANTS.MIN_OBSERVATIONS then
            -- Calculate mean and stddev for this spell
            local sum = 0
            for _, v in ipairs(spellValues) do
                sum = sum + v.value
            end
            local mean = sum / #spellValues
            
            local sumSq = 0
            for _, v in ipairs(spellValues) do
                sumSq = sumSq + (v.value - mean)^2
            end
            local stdDev = math.sqrt(sumSq / #spellValues)
            
            -- Get the value for this entry
            local value
            if entry.changes and entry.changes[field] then
                if field == "resources" then
                    if entry.changes[field].power then
                        value = entry.changes[field].power.delta
                    elseif entry.changes[field].secondary then
                        value = entry.changes[field].secondary.delta
                    end
                else
                    value = entry.changes[field]
                end
            end
            
            -- Only consider it an outlier if it's significantly different from other values for the same spell
            if value and type(value) == "number" and stdDev > 0 then
                local zScore = math.abs(value - mean) / stdDev
                if zScore > threshold then
                    table.insert(outliers, {
                        index = #outliers + 1,
                        value = value,
                        zScore = zScore,
                        spellId = spellId,
                        mean = mean,
                        stdDev = stdDev
                    })
                else
                    table.insert(validEntries, entry)
                end
            else
                -- If we can't calculate a z-score, consider it valid
                table.insert(validEntries, entry)
            end
        else
            -- If we don't have enough samples for this spell, consider it valid
            if spellValues then
                NAG:Debug(format("Skipping outlier detection for %s: insufficient samples (%d < %d)", 
                    groupKey ~= "unknown" and format("spell %d", groupKey) or "unknown spell",
                    #spellValues, CONSTANTS.MIN_OBSERVATIONS))
            end
            table.insert(validEntries, entry)
        end
    end
    
    -- Debug outlier detection results
    if #outliers > 0 then
        NAG:Debug(format("Found %d outliers:", #outliers))
        for _, outlier in ipairs(outliers) do
            local spellName = outlier.spellId and GetSpellInfo(outlier.spellId) or "Unknown"
            NAG:Debug(format("  %s: value=%.2f, z-score=%.2f (mean=%.2f, stddev=%.2f)", 
                outlier.spellId and format("Spell %d (%s)", outlier.spellId, spellName) or "Unknown spell",
                outlier.value, outlier.zScore, outlier.mean, outlier.stdDev))
        end
    end
    
    -- Calculate overall statistics
    local sum = 0
    for _, value in ipairs(values) do
        sum = sum + value
    end
    local mean = #values > 0 and sum / #values or 0
    
    local sumSq = 0
    for _, value in ipairs(values) do
        sumSq = sumSq + (value - mean)^2
    end
    local stdDev = #values > 0 and math.sqrt(sumSq / #values) or 0
    
    return validEntries, outliers, {
        mean = mean,
        stdDev = stdDev,
        sampleSize = #values,
        valuesBySpell = valuesBySpellId
    }
end

-- Helper function to sum values in a table
local function sum(t)
    local s = 0
    for _, v in ipairs(t) do
        s = s + v
    end
    return s
end

-- Add helper functions at the top after the header
local function TableLength(t)
    local count = 0
    for _ in pairs(t) do
        count = count + 1
    end
    return count
end

local function MapTable(t, fn)
    local result = {}
    for k, v in pairs(t) do
        result[k] = fn(v)
    end
    return result
end

-- Modify the rune pattern creation to detect outliers based on rune count consistency
local function analyzeRunePatterns(entries, spellID)
    local patterns = {}
    local validEntries = {}
    local outliers = {}
    local runeCounts = {}  -- Track how many runes each cast uses

    -- Determine if this is a DK spell that uses runes
    local isDKSpell = false
    if spellID then
        local _, class = UnitClass("player")
        if class == "DEATHKNIGHT" then
            isDKSpell = true
        end
    end

    -- First pass: Count pattern frequencies and track rune counts
    for _, entry in ipairs(entries) do
        if entry.changes and entry.changes.runes and entry.changes.runes.spent then
            -- Count runes used in this cast
            local runesUsed = 0
            local pattern = {}
            for runeId, data in pairs(entry.changes.runes.spent) do
                runesUsed = runesUsed + 1
                table.insert(pattern, {id = runeId, type = data.type})
            end

            -- Track rune count frequency
            runeCounts[runesUsed] = (runeCounts[runesUsed] or 0) + 1

            -- Sort pattern for consistent comparison
            table.sort(pattern, function(a, b)
                if a.type == b.type then
                    return a.id < b.id
                end
                return a.type < b.type
            end)

            -- Create pattern key
            local patternKey = table.concat(
                MapTable(pattern, function(r) return tostring(r.type) end),
                ","
            )
            patterns[patternKey] = (patterns[patternKey] or 0) + 1
        end
    end

    -- Find the most common rune count
    local mostCommonCount = 0
    local highestFrequency = 0
    for count, frequency in pairs(runeCounts) do
        if frequency > highestFrequency then
            mostCommonCount = count
            highestFrequency = frequency
        end
    end

    -- Debug output for rune counts
    NAG:Debug("|cFF00FFFFRune Count Analysis:|r")
    for count, frequency in pairs(runeCounts) do
        NAG:Debug(format("  %d rune(s): %d casts (%.1f%%)",
            count, frequency, (frequency / #entries) * 100))
    end
    NAG:Debug(format("Most common rune count: %d", mostCommonCount))

    -- Sort patterns by frequency for debug output
    local sortedPatterns = {}
    for pattern, count in pairs(patterns) do
        table.insert(sortedPatterns, {pattern = pattern, count = count})
    end
    table.sort(sortedPatterns, function(a, b) return a.count > b.count end)

    -- Debug output for patterns
    NAG:Debug("|cFF00FFFFRune Patterns Found:|r")
    for _, data in ipairs(sortedPatterns) do
        NAG:Debug(format("  Pattern: %s (frequency: %d)", data.pattern, data.count))
    end

    -- Second pass: Separate valid entries and outliers
    for _, entry in ipairs(entries) do
        if entry.changes and entry.changes.runes and entry.changes.runes.spent then
            local runesUsed = 0
            local pattern = {}
            for runeId, data in pairs(entry.changes.runes.spent) do
                runesUsed = runesUsed + 1
                table.insert(pattern, {id = runeId, type = data.type})
            end

            -- Sort pattern
            table.sort(pattern, function(a, b)
                if a.type == b.type then
                    return a.id < b.id
                end
                return a.type < b.type
            end)

            local patternKey = table.concat(
                MapTable(pattern, function(r) return tostring(r.type) end),
                ","
            )

            -- For DK spells that use runes, only filter out patterns with the wrong rune count
            local isOutlier = false
            local outlierReason = ""
            if isDKSpell then
                if runesUsed ~= mostCommonCount then
                    isOutlier = true
                    outlierReason = format("Used %d runes instead of expected %d",
                        runesUsed, mostCommonCount)
                end
            else
                -- For non-DK or non-rune spells, keep previous logic (optionally, can be more strict)
                if runesUsed ~= mostCommonCount then
                    isOutlier = true
                    outlierReason = format("Used %d runes instead of expected %d",
                        runesUsed, mostCommonCount)
                elseif patterns[patternKey] < (highestFrequency * 0.2) then
                    isOutlier = true
                    outlierReason = format("Uncommon pattern (frequency: %d)",
                        patterns[patternKey])
                end
            end

            if isOutlier then
                table.insert(outliers, {
                    entry = entry,
                    pattern = patternKey,
                    runesUsed = runesUsed,
                    reason = outlierReason
                })
                NAG:Debug(format("|cFFFF0000Found outlier: %s|r", outlierReason))
            else
                table.insert(validEntries, entry)
            end
        else
            -- If no rune data, consider it valid
            table.insert(validEntries, entry)
        end
    end

    -- Store dominant patterns (those occurring more than 20% of the time)
    local dominantPatterns = {}
    local totalCasts = #entries
    for pattern, count in pairs(patterns) do
        if count / totalCasts > 0.2 then
            dominantPatterns[pattern] = true
            NAG:Debug(format("Dominant pattern found: %s (%.1f%% of casts)",
                pattern, (count / totalCasts) * 100))
        end
    end

    return validEntries, outliers, {
        patterns = patterns,
        dominantPatterns = dominantPatterns,
        mostCommonRuneCount = mostCommonCount,
        runeCounts = runeCounts
    }
end

--- Process entries for a specific spell
function PredictionEngine:ProcessSpellEntries(spellID, entries)
    self:Debug(format("|cFF00FFFF========== Processing Spell %d (%s) ==========|r",
        spellID, GetSpellInfo(spellID) or "Unknown"))
    
    -- Initialize buff tracking
    local buffPresenceCount = {}  -- Track how many times each buff was present
    local buffRemovalCount = {}   -- Track how many times each buff was removed
    
    -- First pass: Count buff presence and removals
    for _, entry in ipairs(entries) do
        if entry.changes and entry.changes.buffs then
            -- Track which buffs were present during the cast
            for buffId, buff in pairs(entry.changes.activePlayerBuffs or {}) do
                buffPresenceCount[buffId] = (buffPresenceCount[buffId] or 0) + 1
            end
            
            -- Track which buffs were removed
            if entry.changes.buffs.lost then
                for buffId, _ in pairs(entry.changes.buffs.lost) do
                    buffRemovalCount[buffId] = (buffRemovalCount[buffId] or 0) + 1
                end
            end
        end
    end
    
    -- First, analyze resource changes for outliers
    local validEntries, resourceOutliers, resourceStats = analyzeOutliers(entries, "resources", 2.5, spellID)
    if #resourceOutliers > 0 then
        self:Debug(format("Found %d resource outliers:", #resourceOutliers))
        for _, outlier in ipairs(resourceOutliers) do
            self:Debug(format("  Entry %d: value=%.2f, z-score=%.2f", 
                outlier.index, outlier.value, outlier.zScore))
        end
    end
    
    -- Then analyze rune patterns if this spell uses runes
    local hasRuneUsage = false
    for _, entry in ipairs(entries) do
        if entry.changes and entry.changes.runes and next(entry.changes.runes.spent) then
            hasRuneUsage = true
            break
        end
    end
    
    if hasRuneUsage then
        validEntries, runeOutliers, runeStats = analyzeRunePatterns(validEntries, spellID)
        if #runeOutliers > 0 then
            self:Debug(format("Found %d rune pattern outliers:", #runeOutliers))
            for _, outlier in ipairs(runeOutliers) do
                self:Debug(format("  Pattern: %s (frequency: %d)", 
                    outlier.pattern, outlier.frequency))
            end
        end
        
        self:Debug("Dominant rune patterns:")
        for pattern in pairs(runeStats.dominantPatterns) do
            self:Debug(format("  %s (frequency: %d)", pattern, runeStats.patterns[pattern]))
        end
    end
    
    -- Group remaining valid entries by context
    local contextGroups = self:GroupEntriesByContext(validEntries)
    
    self:Debug(format("|cFF00FFFFFound %d valid context groups after outlier filtering|r", 
        TableLength(contextGroups)))
    
    -- Process each context group with enhanced buff tracking
    for contextKey, groupEntries in pairs(contextGroups) do
        self:Debug(format("|cFF00FFFFProcessing context '%s' with %d entries|r", 
            contextKey, #groupEntries))
        
        -- Create a summary for this context
        local summary = {
            count = #groupEntries,
            cost = {},
            generates = {},
            applies = {},
            removes = {},
            confidence = {},
            buffStats = {  -- New structure for detailed buff statistics
                presence = buffPresenceCount,
                removals = buffRemovalCount,
                removalRates = {}  -- Will store calculated removal rates
            }
        }
        
        -- Calculate removal rates based on presence
        for buffId, presentCount in pairs(buffPresenceCount) do
            local removedCount = buffRemovalCount[buffId] or 0
            -- Only calculate rate if buff was ever present
            if presentCount > 0 then
                summary.buffStats.removalRates[buffId] = removedCount / presentCount
                
                -- Debug output for buff interaction rates
                local buffName = GetSpellInfo(buffId) or "Unknown"
                self:Debug(format("Buff interaction analysis for %s (ID: %d):", buffName, buffId))
                self:Debug(format("  Present in %d/%d casts (%.1f%%)", 
                    presentCount, #groupEntries, (presentCount / #groupEntries) * 100))
                self:Debug(format("  Removed in %d/%d opportunities (%.1f%%)", 
                    removedCount, presentCount, (removedCount / presentCount) * 100))
            end
        end
        
        -- Process entries with the enhanced summary
        for _, entry in ipairs(groupEntries) do
            self:ProcessEntry(summary, entry)
        end
        
        -- Update removal rates in the main summary based on actual presence
        for buffId, rate in pairs(summary.buffStats.removalRates) do
            if rate > 0.8 then  -- If buff is removed more than 80% of the time when present
                summary.removes[buffId] = rate
                self:Debug(format("Learned: %s removes buff %s %.1f%% of the time when present", 
                    GetSpellInfo(spellID) or "Unknown",
                    GetSpellInfo(buffId) or "Unknown",
                    rate * 100))
            end
        end
        
        -- Finalize summary and merge into compiled data
        self:FinalizeSummary(summary)
        self:MergeIntoCompiled(spellID, contextKey, summary)
        self:PrintContextSummary(spellID, contextKey, summary)
    end
end

--- Group entries by their buff context
function PredictionEngine:GroupEntriesByContext(entries)
    local groups = {}
    
    for _, entry in ipairs(entries) do
        local contextKey = self:GenerateContextKey(entry.changes.activePlayerBuffs)
        if not groups[contextKey] then
            groups[contextKey] = {}
        end
        tinsert(groups[contextKey], entry)
    end
    
    return groups
end

--- Generate a context key from active buffs
function PredictionEngine:GenerateContextKey(buffs)
    if not buffs or not next(buffs) then
        return "default"
    end
    
    -- Sort buff IDs to ensure consistent keys
    local buffIds = {}
    for id in pairs(buffs) do
        tinsert(buffIds, id)
    end
    table.sort(buffIds)
    
    -- Create key from sorted IDs
    return "buff_" .. table.concat(buffIds, "_")
end

--- Process a group of entries with the same context
function PredictionEngine:ProcessContextGroup(spellID, contextKey, entries)
    local summary = {
        count = #entries,
        cost = {},
        generates = {},
        applies = {},
        removes = {},
        confidence = {}
    }
    
    self:Debug(format("|cFF00FFFFProcessing %d entries for context '%s'|r", 
        #entries, contextKey))
    
    -- Process each entry
    for _, entry in ipairs(entries) do
        self:ProcessEntry(summary, entry)
    end
    
    -- Calculate averages and confidence
    self:FinalizeSummary(summary)
    
    -- Merge with existing data
    self:MergeIntoCompiled(spellID, contextKey, summary)
    
    -- Print summary
    self:PrintContextSummary(spellID, contextKey, summary)
end

--- Process a single entry into the summary
function PredictionEngine:ProcessEntry(summary, entry)
    -- Track resource caps if state is available
    if entry.state then
        self:UpdateResourceCaps(entry.state)
    end
    
    -- Process resource changes
    if entry.changes.resources then
        -- Primary resource
        if entry.changes.resources.power then
            local delta = entry.changes.resources.power.delta
            if delta < 0 then
                -- Store individual cost values for median calculation
                if not summary.costSamples then summary.costSamples = {} end
                if not summary.costSamples[entry.changes.resources.power.powerType] then 
                    summary.costSamples[entry.changes.resources.power.powerType] = {}
                end
                tinsert(summary.costSamples[entry.changes.resources.power.powerType], {
                    value = math.abs(delta),
                    resourceType = entry.changes.resources.power.powerType,
                    context = entry.changes.activePlayerBuffs,
                    runes = entry.changes.runes,
                    eclipse = entry.changes.eclipse,
                    state = entry.state -- Include full state for analysis
                })
            elseif delta > 0 then
                -- Store individual generation values for median calculation
                if not summary.generatesSamples then summary.generatesSamples = {} end
                if not summary.generatesSamples[entry.changes.resources.power.powerType] then 
                    summary.generatesSamples[entry.changes.resources.power.powerType] = {}
                end
                tinsert(summary.generatesSamples[entry.changes.resources.power.powerType], {
                    value = delta,
                    resourceType = entry.changes.resources.power.powerType,
                    context = entry.changes.activePlayerBuffs,
                    runes = entry.changes.runes,
                    eclipse = entry.changes.eclipse,
                    state = entry.state -- Include full state for analysis
                })
            end
        end
        
        -- Secondary resource
        if entry.changes.resources.secondary then
            local delta = entry.changes.resources.secondary.delta
            if delta < 0 then
                if not summary.costSamples then summary.costSamples = {} end
                if not summary.costSamples[entry.changes.resources.secondary.powerType] then 
                    summary.costSamples[entry.changes.resources.secondary.powerType] = {}
                end
                tinsert(summary.costSamples[entry.changes.resources.secondary.powerType], {
                    value = math.abs(delta),
                    resourceType = entry.changes.resources.secondary.powerType,
                    context = entry.changes.activePlayerBuffs,
                    runes = entry.changes.runes,
                    eclipse = entry.changes.eclipse,
                    state = entry.state -- Include full state for analysis
                })
            elseif delta > 0 then
                if not summary.generatesSamples then summary.generatesSamples = {} end
                if not summary.generatesSamples[entry.changes.resources.secondary.powerType] then 
                    summary.generatesSamples[entry.changes.resources.secondary.powerType] = {}
                end
                tinsert(summary.generatesSamples[entry.changes.resources.secondary.powerType], {
                    value = delta,
                    resourceType = entry.changes.resources.secondary.powerType,
                    context = entry.changes.activePlayerBuffs,
                    runes = entry.changes.runes,
                    eclipse = entry.changes.eclipse,
                    state = entry.state -- Include full state for analysis
                })
            end
        end
    end
    
    -- Process rune changes for DKs
    if entry.changes.runes then
        summary.runeUsage = summary.runeUsage or {
            spent = {},
            converted = {},
            totalSpent = 0,
            combinations = {}, -- Track combinations of runes used per cast
            availableNotUsed = {}, -- Track which runes were available but not chosen
            runesPerCast = {}, -- Track how many runes each cast used
            preferredTypes = {}, -- Track preferred rune types when multiple options exist
            typePatterns = {} -- Track all observed rune type combinations
        }
        
        -- Track runes spent in this cast
        local thiscastRunes = {}
        local thiscastTypes = {}
        local runesByType = {}
        
        -- First pass: Count runes by type
        for runeId, data in pairs(entry.changes.runes.spent) do
            runesByType[data.type] = (runesByType[data.type] or 0) + 1
        end
        
        -- Only process if we have runes spent (avoid partial captures)
        if next(runesByType) then
            -- Create type pattern based on total runes of each type
            local typePattern = {}
            for runeType, count in pairs(runesByType) do
                table.insert(typePattern, {type = runeType, count = count})
            end
            
            -- Sort by type for consistent pattern
            table.sort(typePattern, function(a, b) return a.type < b.type end)
            
            -- Create pattern key
            local patternKey = ""
            local totalRunesInPattern = 0
            for _, rune in ipairs(typePattern) do
                -- Repeat the type number based on count
                for i = 1, rune.count do
                    if patternKey ~= "" then
                        patternKey = patternKey .. ","
                    end
                    patternKey = patternKey .. rune.type
                    totalRunesInPattern = totalRunesInPattern + 1
                end
            end
            
            -- Track the pattern only if it's complete
            -- We determine if a pattern is complete by checking if all runes spent in this cast
            -- are accounted for in the pattern
            local totalRunesSpent = 0
            for _, count in pairs(runesByType) do
                totalRunesSpent = totalRunesSpent + count
            end
            
            -- Only store the pattern if it matches the total runes spent
            if totalRunesInPattern == totalRunesSpent then
                -- Track the pattern
                summary.runeUsage.typePatterns[patternKey] = (summary.runeUsage.typePatterns[patternKey] or 0) + 1
                
                -- Track individual rune usage
                for runeId, data in pairs(entry.changes.runes.spent) do
                    summary.runeUsage.spent[runeId] = summary.runeUsage.spent[runeId] or {
                        count = 0,
                        type = data.type
                    }
                    summary.runeUsage.spent[runeId].count = summary.runeUsage.spent[runeId].count + 1
                    summary.runeUsage.totalSpent = summary.runeUsage.totalSpent + 1
                    
                    -- Track preferred types
                    summary.runeUsage.preferredTypes[data.type] = (summary.runeUsage.preferredTypes[data.type] or 0) + 1
                end
                
                -- Track runes per cast
                summary.runeUsage.runesPerCast[totalRunesSpent] = (summary.runeUsage.runesPerCast[totalRunesSpent] or 0) + 1
            else
                -- Debug output for incomplete patterns
                if self:GetGlobal().debugMode then
                    self:Debug(format("Skipping incomplete rune pattern: %s (Total runes: %d, Pattern runes: %d)", 
                        patternKey, totalRunesSpent, totalRunesInPattern))
                end
            end
        end
        
        -- Track available but unused runes
        if entry.changes.runes.available then
            for runeId, data in pairs(entry.changes.runes.available) do
                if not entry.changes.runes.spent[runeId] then
                    summary.runeUsage.availableNotUsed[runeId] = summary.runeUsage.availableNotUsed[runeId] or {
                        count = 0,
                        type = data.type
                    }
                    summary.runeUsage.availableNotUsed[runeId].count = summary.runeUsage.availableNotUsed[runeId].count + 1
                end
            end
        end
    end
    
    -- Process eclipse changes for Druids
    if entry.changes.eclipse then
        summary.eclipse = summary.eclipse or {
            phase = {},
            solarEnergy = {},
            lunarEnergy = {},
            direction = {}
        }
        
        -- Track phase changes
        if entry.changes.eclipse.phase and entry.changes.eclipse.phase.changed then
            summary.eclipse.phase[entry.changes.eclipse.phase.newPhase] = 
                (summary.eclipse.phase[entry.changes.eclipse.phase.newPhase] or 0) + 1
        end
        
        -- Track energy changes
        if entry.changes.eclipse.solarEnergy and entry.changes.eclipse.solarEnergy.changed then
            tinsert(summary.eclipse.solarEnergy, {
                oldValue = entry.changes.eclipse.solarEnergy.oldValue,
                newValue = entry.changes.eclipse.solarEnergy.newValue,
                delta = entry.changes.eclipse.solarEnergy.delta
            })
        end
        
        if entry.changes.eclipse.lunarEnergy and entry.changes.eclipse.lunarEnergy.changed then
            tinsert(summary.eclipse.lunarEnergy, {
                oldValue = entry.changes.eclipse.lunarEnergy.oldValue,
                newValue = entry.changes.eclipse.lunarEnergy.newValue,
                delta = entry.changes.eclipse.lunarEnergy.delta
            })
        end
        
        -- Track direction changes
        if entry.changes.eclipse.direction and entry.changes.eclipse.direction.changed then
            summary.eclipse.direction[entry.changes.eclipse.direction.newDirection] = 
                (summary.eclipse.direction[entry.changes.eclipse.direction.newDirection] or 0) + 1
        end
    end
    
    -- Process buff applications
    if entry.changes.buffs and entry.changes.buffs.player then
        for buffId, buff in pairs(entry.changes.buffs.player.gained) do
            summary.applies[buffId] = (summary.applies[buffId] or 0) + 1
        end
    end
    
    -- Process buff removals
    if entry.changes.buffs and entry.changes.buffs.player then
        for buffId, buff in pairs(entry.changes.buffs.player.lost) do
            summary.removes[buffId] = (summary.removes[buffId] or 0) + 1
        end
    end
end

--- Calculate trimmed median from a sorted array
function PredictionEngine:CalculateTrimmedMedian(values)
    if not values or #values == 0 then return 0 end
    
    -- Sort the values
    table.sort(values)
    
    -- Calculate trim points
    local trimCount = math.floor(#values * CONSTANTS.TRIM_PERCENTAGE)
    local startIdx = trimCount + 1
    local endIdx = #values - trimCount
    
    -- If we trimmed too much, return regular median
    if startIdx >= endIdx then
        return self:CalculateMedian(values)
    end
    
    -- Calculate median of trimmed values
    local mid = math.floor((startIdx + endIdx) / 2)
    if (endIdx - startIdx + 1) % 2 == 0 then
        return (values[mid] + values[mid + 1]) / 2
    else
        return values[mid]
    end
end

--- Calculate weight for processed data based on age
function PredictionEngine:CalculateDataWeight(processTime)
    local currentTime = GetTime()
    local ageInProcessings = (currentTime - processTime) / CONSTANTS.PROCESSING_COOLDOWN
    return math.max(0.1, 1 - (ageInProcessings * CONSTANTS.WEIGHT_DECAY_RATE))
end

--- Store processed results in history
function PredictionEngine:StoreProcessedResults(spellID, contextKey, summary)
    if not self:GetChar().processedHistory[spellID] then
        self:GetChar().processedHistory[spellID] = {}
    end
    
    if not self:GetChar().processedHistory[spellID][contextKey] then
        self:GetChar().processedHistory[spellID][contextKey] = {}
    end
    
    -- Add new result
    tinsert(self:GetChar().processedHistory[spellID][contextKey], {
        timestamp = GetTime(),
        summary = summary
    })
    
    -- Trim history if too long
    while #self:GetChar().processedHistory[spellID][contextKey] > CONSTANTS.MAX_PROCESSED_HISTORY do
        tremove(self:GetChar().processedHistory[spellID][contextKey], 1)
    end
end

--- Merge new summary into compiled data with dynamic weights
function PredictionEngine:MergeIntoCompiled(spellID, contextKey, newSummary)
    -- Initialize compiled data if needed
    if not self:GetChar().compiled[spellID] then
        self:GetChar().compiled[spellID] = {}
    end
    
    local compiled = self:GetChar().compiled[spellID]
    local oldSummary = compiled[contextKey]
    
    -- Store the new result in history
    self:StoreProcessedResults(spellID, contextKey, newSummary)
    
    if not oldSummary then
        -- First time seeing this context
        compiled[contextKey] = newSummary
        return
    end
    
    -- Get all historical results
    local history = self:GetChar().processedHistory[spellID][contextKey]
    local totalWeight = 0
    local weightedValues = {
        cost = {},
        generates = {},
        applies = {},
        removes = {}
    }
    
    -- Calculate weighted values from history
    for _, result in ipairs(history) do
        local weight = self:CalculateDataWeight(result.timestamp)
        totalWeight = totalWeight + weight
        
        -- Merge costs
        for resourceType, value in pairs(result.summary.cost) do
            weightedValues.cost[resourceType] = (weightedValues.cost[resourceType] or 0) + (value * weight)
        end
        
        -- Merge generation
        for resourceType, value in pairs(result.summary.generates) do
            weightedValues.generates[resourceType] = (weightedValues.generates[resourceType] or 0) + (value * weight)
        end
        
        -- Merge buff applications
        for buffId, value in pairs(result.summary.applies) do
            weightedValues.applies[buffId] = (weightedValues.applies[buffId] or 0) + (value * weight)
        end
        
        -- Merge buff removals
        for buffId, value in pairs(result.summary.removes) do
            weightedValues.removes[buffId] = (weightedValues.removes[buffId] or 0) + (value * weight)
        end
    end
    
    -- Calculate final weighted averages
    for resourceType, value in pairs(weightedValues.cost) do
        compiled[contextKey].cost[resourceType] = value / totalWeight
    end
    
    for resourceType, value in pairs(weightedValues.generates) do
        compiled[contextKey].generates[resourceType] = value / totalWeight
    end
    
    for buffId, value in pairs(weightedValues.applies) do
        compiled[contextKey].applies[buffId] = value / totalWeight
    end
    
    for buffId, value in pairs(weightedValues.removes) do
        compiled[contextKey].removes[buffId] = value / totalWeight
    end
    
    -- Update count
    compiled[contextKey].count = #history
    
    -- Merge outliers
    if newSummary.outliers then
        compiled[contextKey].outliers = compiled[contextKey].outliers or {}
        for category, outliers in pairs(newSummary.outliers) do
            compiled[contextKey].outliers[category] = compiled[contextKey].outliers[category] or {}
            for _, outlier in ipairs(outliers) do
                tinsert(compiled[contextKey].outliers[category], outlier)
            end
        end
    end
    
    -- Update confidence (weighted average)
    for aspect, newConfTable in pairs(newSummary.confidence) do
        compiled[contextKey].confidence[aspect] = compiled[contextKey].confidence[aspect] or {}
        
        -- For each specific confidence value (like specific spell IDs or resource types)
        for key, newConfValue in pairs(newConfTable) do
            local oldConfValue = (oldSummary.confidence[aspect] and oldSummary.confidence[aspect][key]) or 0
            local oldCount = oldSummary.count or 0
            local newCount = newSummary.count or 0
            local totalCount = oldCount + newCount
            
            -- Calculate weighted average of confidence
            compiled[contextKey].confidence[aspect][key] = 
                ((oldConfValue * oldCount) + (newConfValue * newCount)) / totalCount
        end
    end
end

--- Finalize the summary with trimmed medians and confidence
function PredictionEngine:FinalizeSummary(summary)
    local count = summary.count
    
    -- Calculate trimmed medians for costs
    if summary.costSamples then
        for resourceType, samples in pairs(summary.costSamples) do
            -- Extract values for median calculation
            local values = {}
            for _, sample in ipairs(samples) do
                tinsert(values, sample.value)
            end
            
            -- Calculate trimmed median
            summary.cost[resourceType] = self:CalculateTrimmedMedian(values)
            
            -- Detect outliers
            local outliers = self:DetectOutliers(values)
            if #outliers > 0 then
                summary.outliers = summary.outliers or {}
                summary.outliers.cost = summary.outliers.cost or {}
                summary.outliers.cost[resourceType] = {}
                
                -- Analyze each outlier
                for _, outlier in ipairs(outliers) do
                    local sample = samples[outlier.index]
                    local analysis = self:AnalyzeOutliers({outlier}, sample.context, summary.spellID)
                    tinsert(summary.outliers.cost[resourceType], {
                        value = outlier.value,
                        analysis = analysis
                    })
                end
            end
            
            -- Calculate confidence based on variance
            local variance = 0
            for _, value in ipairs(values) do
                variance = variance + (value - summary.cost[resourceType])^2
            end
            variance = variance / #values
            
            -- Higher variance = lower confidence
            summary.confidence.cost = summary.confidence.cost or {}
            summary.confidence.cost[resourceType] = 1 / (1 + variance)
        end
    end
    
    -- Calculate trimmed medians for generation
    if summary.generatesSamples then
        for resourceType, samples in pairs(summary.generatesSamples) do
            -- Extract values for median calculation
            local values = {}
            for _, sample in ipairs(samples) do
                tinsert(values, sample.value)
            end
            
            -- Calculate trimmed median
            summary.generates[resourceType] = self:CalculateTrimmedMedian(values)
            
            -- Detect outliers
            local outliers = self:DetectOutliers(values)
            if #outliers > 0 then
                summary.outliers = summary.outliers or {}
                summary.outliers.generates = summary.outliers.generates or {}
                summary.outliers.generates[resourceType] = {}
                
                -- Analyze each outlier
                for _, outlier in ipairs(outliers) do
                    local sample = samples[outlier.index]
                    local analysis = self:AnalyzeOutliers({outlier}, sample.context, summary.spellID)
                    tinsert(summary.outliers.generates[resourceType], {
                        value = outlier.value,
                        analysis = analysis
                    })
                end
            end
            
            -- Calculate confidence based on variance
            local variance = 0
            for _, value in ipairs(values) do
                variance = variance + (value - summary.generates[resourceType])^2
            end
            variance = variance / #values
            
            -- Higher variance = lower confidence
            summary.confidence.generates = summary.confidence.generates or {}
            summary.confidence.generates[resourceType] = 1 / (1 + variance)
        end
    end
    
    -- Calculate confidence for buff applications
    for buffId, count in pairs(summary.applies) do
        summary.applies[buffId] = count / summary.count
        summary.confidence.applies = summary.confidence.applies or {}
        summary.confidence.applies[buffId] = count / summary.count
    end
    
    -- Calculate confidence for buff removals
    for buffId, count in pairs(summary.removes) do
        summary.removes[buffId] = count / summary.count
        summary.confidence.removes = summary.confidence.removes or {}
        summary.confidence.removes[buffId] = count / summary.count
    end
    
    -- Clean up temporary data
    summary.costSamples = nil
    summary.generatesSamples = nil
end

--- Update predictions based on current state
function PredictionEngine:UpdatePredictions()
    if not self:GetChar().enabled then return end
    
    -- Get current state from StateManager
    local currentState = self.stateManager:CaptureCurrentState()
    if not currentState then
        self:Debug("Failed to capture current state")
        return
    end
    
    -- Update current context
    self:UpdateCurrentContext(currentState)
    
    -- Clear existing predictions
    wipe(self.state.predictions)
    
    -- Generate predictions up to configured depth
    local depth = self:GetGlobal().predictionDepth
    local predictions = self:PredictActions(currentState, depth)
    
    -- Track the first prediction for feedback
    if predictions and predictions[1] then
        self:TrackPrediction(predictions[1])
    end
    
    -- Debug output
    if self:GetGlobal().debugMode then
        self:PrintPredictions()
    end
end

--- Update current buff context
function PredictionEngine:UpdateCurrentContext(state)
    wipe(self.state.currentContext)
    
    -- Get active buffs
    for spellId, buff in pairs(state.buffs.player) do
        self.state.currentContext[spellId] = true
    end
end

--- Predict optimal actions based on current state
function PredictionEngine:PredictActions(initialState, depth)
    -- Placeholder for actual prediction logic
    -- This will be implemented based on learned spell effects
    local predictions = {}
    
    for i = 1, depth do
        -- Get best next action using rotation logic
        local nextAction = self:GetBestAction(initialState)
        if not nextAction then break end
        
        -- Store the predicted action
        tinsert(predictions, nextAction)
        
        -- Apply predicted effects to get next state
        initialState = self:ApplyPredictedEffects(initialState, nextAction)
    end
    
    self.state.predictions = predictions
    return predictions
end

--- Get best next action based on simulated state
function PredictionEngine:GetBestAction(state)
    -- Placeholder - will be implemented with actual rotation logic
    -- For now, just return nil to indicate no prediction
    return nil
end

--- Apply predicted effects of an action to a state
function PredictionEngine:ApplyPredictedEffects(state, action)
    -- Use the PredictionAPI to apply spell effects
    if NAG.PredictionAPI then
        return NAG.PredictionAPI:ApplySpellEffects(action, state)
    else
        self:Debug("|cFFFF0000PredictionAPI not available! Cannot apply spell effects.|r")
        return state
    end
end

--- Print current predictions
function PredictionEngine:PrintPredictions()
    if not self:GetGlobal().debugMode then return end
    
    self:Debug("==============================================")
    self:Debug("Current Predictions:")
    
    if #self.state.predictions == 0 then
        self:Debug("  No predictions available")
    else
        for i, spellID in ipairs(self.state.predictions) do
            local spellName = GetSpellInfo(spellID) or "Unknown"
            self:Debug(format("  %d. %s (ID: %d)", i, spellName, spellID))
        end
    end
    
    self:Debug("==============================================")
end

--- Gets the options table for module settings
--- @return table The options table for AceConfig
function PredictionEngine:GetOptions()
    return {
        general = {
            type = "group",
            name = L["general"],
            order = 1,
            args = {
                debugMode = {
                    type = "toggle",
                    name = L["debugMode"],
                    desc = L["debugModeDesc"],
                    order = 1,
                    get = function() return self:GetGlobal().debugMode end,
                    set = function(_, value)
                        self:GetGlobal().debugMode = value
                        LibStub("AceConfigRegistry-3.0"):NotifyChange("NAG")
                    end,
                },
                enabled = {
                    type = "toggle",
                    name = L["enabled"],
                    desc = L["enabledDesc"],
                    order = 2,
                    get = function() return self:GetChar().enabled end,
                    set = function(_, value)
                        self:GetChar().enabled = value
                        if value then
                            self:Enable()
                        else
                            self:Disable()
                        end
                        LibStub("AceConfigRegistry-3.0"):NotifyChange("NAG")
                    end,
                },
                predictionDepth = {
                    type = "range",
                    name = L["predictionDepth"],
                    desc = L["predictionDepthDesc"],
                    order = 3,
                    min = 1,
                    max = 5,
                    step = 1,
                    get = function() return self:GetGlobal().predictionDepth end,
                    set = function(_, value)
                        self:GetGlobal().predictionDepth = value
                        LibStub("AceConfigRegistry-3.0"):NotifyChange("NAG")
                    end,
                },
            }
        }
    }
end

-- Make module available globally through NAG
ns.PredictionEngine = PredictionEngine 

--- Check if a spell can be cast with current rune state
function PredictionEngine:CheckRuneAvailability(spellID, state)
    local combinations = CONSTANTS.RUNE_COMBINATIONS[spellID]
    if not combinations then return true end  -- Spell doesn't use runes
    
    -- Get available runes
    local availableRunes = {
        [CONSTANTS.RUNE_TYPE.BLOOD] = 0,
        [CONSTANTS.RUNE_TYPE.FROST] = 0,
        [CONSTANTS.RUNE_TYPE.UNHOLY] = 0,
        [CONSTANTS.RUNE_TYPE.DEATH] = 0
    }
    
    for i = 1, CONSTANTS.MAX_RUNES do
        if state.runes[i].ready then
            availableRunes[state.runes[i].type] = availableRunes[state.runes[i].type] + 1
        end
    end
    
    -- Check each possible combination
    for _, combination in ipairs(combinations) do
        local canCast = true
        for runeType, count in pairs(combination) do
            if availableRunes[runeType] < count then
                canCast = false
                break
            end
        end
        if canCast then return true end
    end
    
    return false
end

--- Analyze outliers to determine their cause
function PredictionEngine:AnalyzeOutliers(outliers, state, spellID)
    local analysis = {
        resourceCaps = {},
        buffEffects = {},
        runeEffects = {},
        other = {}
    }
    
    for _, outlier in ipairs(outliers) do
        local cause = self:DetermineOutlierCause(outlier, state, spellID)
        if cause then
            table.insert(analysis[cause.category], {
                value = outlier.value,
                cause = cause.reason,
                context = cause.context
            })
        else
            table.insert(analysis.other, {
                value = outlier.value,
                reason = "Unknown cause"
            })
        end
    end
    
    return analysis
end

--- Determine the cause of an outlier
function PredictionEngine:DetermineOutlierCause(outlier, state, spellID)
    -- Check for resource caps
    if outlier.resourceType then
        local cap = CONSTANTS.RESOURCE_CAPS[outlier.resourceType]
        if cap and outlier.value >= cap then
            return {
                category = "resourceCaps",
                reason = "Resource cap reached",
                context = {
                    resourceType = outlier.resourceType,
                    cap = cap,
                    currentValue = state.resources[outlier.resourceType]
                }
            }
        end
    end
    
    -- Check for buff effects
    if state.buffs then
        for buffId, buff in pairs(state.buffs) do
            -- Check if this buff is known to affect the spell
            local spellData = self:GetChar().compiled[spellID]
            if spellData and spellData[buffId] then
                return {
                    category = "buffEffects",
                    reason = "Active buff affecting spell",
                    context = {
                        buffId = buffId,
                        buffName = GetSpellInfo(buffId),
                        effect = spellData[buffId]
                    }
                }
            end
        end
    end
    
    -- Check for rune effects using learned data
    if spellID then
        local spellData = self:GetChar().compiled[spellID]
        if spellData then
            -- Get all learned rune combinations for this spell
            local runeCombinations = self:GetLearnedRuneCombinations(spellID)
            if runeCombinations and #runeCombinations > 0 then
                -- Check if the outlier might be related to rune usage
                local availableRunes = self:GetAvailableRunes(state)
                local canCast = false
                
                -- Try each combination
                for _, combo in ipairs(runeCombinations) do
                    local canUseCombo = true
                    for _, rune in ipairs(combo) do
                        if (availableRunes[rune.type] or 0) < rune.count then
                            canUseCombo = false
                            break
                        end
                    end
                    if canUseCombo then
                        canCast = true
                        break
                    end
                end
                
                if not canCast then
                    return {
                        category = "runeEffects",
                        reason = "Insufficient runes for any known combination",
                        context = {
                            availableRunes = availableRunes,
                            learnedCombinations = runeCombinations
                        }
                    }
                end
            end
        end
    end
    
    return nil
end

--- Get current rune state
function PredictionEngine:GetRuneState(state)
    if not state.runes then return nil end
    
    local runeState = {
        available = {
            [CONSTANTS.RUNE_TYPE.BLOOD] = 0,
            [CONSTANTS.RUNE_TYPE.FROST] = 0,
            [CONSTANTS.RUNE_TYPE.UNHOLY] = 0,
            [CONSTANTS.RUNE_TYPE.DEATH] = 0
        },
        cooldowns = {}
    }
    
    for i = 1, CONSTANTS.MAX_RUNES do
        if state.runes[i].ready then
            runeState.available[state.runes[i].type] = runeState.available[state.runes[i].type] + 1
        else
            table.insert(runeState.cooldowns, {
                type = state.runes[i].type,
                timeLeft = state.runes[i].timeLeft
            })
        end
    end
    
    return runeState
end

--- Detect statistical outliers in a dataset using the Interquartile Range (IQR) method
-- @param values Table of numeric values to analyze
-- @return Table of outliers with their indices and values
function PredictionEngine:DetectOutliers(values)
    if not values or #values < 4 then
        -- Not enough data points for reliable outlier detection
        return {}
    end

    -- Sort values for quartile calculation
    table.sort(values)
    local n = #values

    -- Calculate quartile positions
    local q1_pos = math.floor(n * 0.25)
    local q3_pos = math.floor(n * 0.75)

    -- Get quartile values, ensuring we have valid positions
    local q1 = values[math.max(1, q1_pos)]
    local q3 = values[math.min(n, q3_pos)]

    -- Calculate IQR and bounds
    local iqr = q3 - q1
    local lower_bound = q1 - (1.5 * iqr)
    local upper_bound = q3 + (1.5 * iqr)

    -- Find outliers
    local outliers = {}
    for i, value in ipairs(values) do
        if value < lower_bound or value > upper_bound then
            table.insert(outliers, {
                index = i,
                value = value,
                isLow = value < lower_bound,
                isHigh = value > upper_bound
            })
        end
    end

    return outliers
end

--- Calculate median of a sorted array
-- @param values Sorted table of numeric values
-- @return Median value
function PredictionEngine:CalculateMedian(values)
    if not values or #values == 0 then
        return 0
    end

    local n = #values
    if n % 2 == 0 then
        -- Even number of values, average the middle two
        return (values[n/2] + values[(n/2) + 1]) / 2
    else
        -- Odd number of values, take the middle one
        return values[math.floor(n/2) + 1]
    end
end

--- Print summary of processed context
function PredictionEngine:PrintContextSummary(spellID, contextKey, summary)
    self:Debug(format("|cFF00FFFF=== Summary for %s (ID: %d) in context '%s' ===|r", 
        GetSpellInfo(spellID) or "Unknown", spellID, contextKey))
    
    -- Print costs
    if next(summary.cost) then
        self:Debug("|cFF00FFFFCosts:|r")
        for resourceType, value in pairs(summary.cost) do
            local resourceName = _G[format("POWER_TYPE_%d", resourceType)] or resourceType
            self:Debug(format("  %s: %.1f (confidence: %.2f)", 
                resourceName, value, summary.confidence.cost[resourceType] or 0))
        end
    end
    
    -- Print generation
    if next(summary.generates) then
        self:Debug("|cFF00FFFFGenerates:|r")
        for resourceType, value in pairs(summary.generates) do
            local resourceName = _G[format("POWER_TYPE_%d", resourceType)] or resourceType
            self:Debug(format("  %s: %.1f (confidence: %.2f)", 
                resourceName, value, summary.confidence.generates[resourceType] or 0))
        end
    end
    
    -- Print rune usage for DKs
    if summary.runeUsage then
        self:Debug("|cFF00FFFFRune Usage:|r")
        self:Debug(format("  Total runes spent: %d", summary.runeUsage.totalSpent))
        
        if next(summary.runeUsage.spent) then
            self:Debug("  Spent runes:")
            for runeId, data in pairs(summary.runeUsage.spent) do
                local typeStr = data.type == CONSTANTS.RUNE_TYPE.BLOOD and "Blood" 
                    or data.type == CONSTANTS.RUNE_TYPE.FROST and "Frost"
                    or data.type == CONSTANTS.RUNE_TYPE.UNHOLY and "Unholy"
                    or data.type == CONSTANTS.RUNE_TYPE.DEATH and "Death"
                    or "Unknown"
                self:Debug(format("    Rune %d (%s): %d times", runeId, typeStr, data.count))
            end
        end
        
        if next(summary.runeUsage.converted) then
            self:Debug("  Converted runes:")
            for runeId, data in pairs(summary.runeUsage.converted) do
                local fromTypeStr = data.fromType == CONSTANTS.RUNE_TYPE.BLOOD and "Blood" 
                    or data.fromType == CONSTANTS.RUNE_TYPE.FROST and "Frost"
                    or data.fromType == CONSTANTS.RUNE_TYPE.UNHOLY and "Unholy"
                    or data.fromType == CONSTANTS.RUNE_TYPE.DEATH and "Death"
                    or "Unknown"
                local toTypeStr = data.toType == CONSTANTS.RUNE_TYPE.BLOOD and "Blood" 
                    or data.toType == CONSTANTS.RUNE_TYPE.FROST and "Frost"
                    or data.toType == CONSTANTS.RUNE_TYPE.UNHOLY and "Unholy"
                    or data.toType == CONSTANTS.RUNE_TYPE.DEATH and "Death"
                    or "Unknown"
                self:Debug(format("    Rune %d: %s -> %s (%d times)", 
                    runeId, fromTypeStr, toTypeStr, data.count))
            end
        end
    end
    
    -- Print eclipse information for Druids
    if summary.eclipse then
        self:Debug("|cFF00FFFFEclipse Information:|r")
        
        if next(summary.eclipse.phase) then
            self:Debug("  Phase changes:")
            for phase, count in pairs(summary.eclipse.phase) do
                self:Debug(format("    %s: %d times", phase, count))
            end
        end
        
        if #summary.eclipse.solarEnergy > 0 then
            self:Debug("  Solar Energy changes:")
            local totalDelta = 0
            for _, change in ipairs(summary.eclipse.solarEnergy) do
                totalDelta = totalDelta + change.delta
            end
            self:Debug(format("    Average change: %.1f", totalDelta / #summary.eclipse.solarEnergy))
        end
        
        if #summary.eclipse.lunarEnergy > 0 then
            self:Debug("  Lunar Energy changes:")
            local totalDelta = 0
            for _, change in ipairs(summary.eclipse.lunarEnergy) do
                totalDelta = totalDelta + change.delta
            end
            self:Debug(format("    Average change: %.1f", totalDelta / #summary.eclipse.lunarEnergy))
        end
        
        if next(summary.eclipse.direction) then
            self:Debug("  Direction changes:")
            for direction, count in pairs(summary.eclipse.direction) do
                self:Debug(format("    %s: %d times", direction, count))
            end
        end
    end
    
    -- Print outliers if any
    if summary.outliers then
        self:Debug("|cFF00FFFFOutliers:|r")
        for category, outliers in pairs(summary.outliers) do
            self:Debug(format("  %s: %d outliers", category, #outliers))
        end
    end
    
    self:Debug("|cFF00FFFF==============================================|r")
end

--- Inspect learned costs
function PredictionEngine:InspectLearnedCosts(spellID)
    if not self:GetChar().compiled then
        self:Debug("|cFFFF0000No learned costs found|r")
        return
    end
    
    if spellID then
        -- Show data for specific spell
        local spellData = self:GetChar().compiled[spellID]
        if not spellData then
            self:Debug(format("|cFFFF0000No learned costs found for spell ID: %d|r", spellID))
            return
        end
        
        self:Debug(format("|cFF00FFFF===== Learned Costs for %s (ID: %d) =====|r", 
            GetSpellInfo(spellID) or "Unknown",
            spellID))
        
        -- Show each context
        for contextKey, data in pairs(spellData) do
            self:Debug(format("\nContext: %s", contextKey))
            self:Debug(format("Total observations: %d", data.count))
            
            -- Show costs
            if next(data.cost) then
                self:Debug("Costs:")
                for resourceType, value in pairs(data.cost) do
                    local resourceName = _G[format("POWER_TYPE_%d", resourceType)] or resourceType
                    self:Debug(format("  %s: %.1f (confidence: %.2f)", 
                        resourceName, value, data.confidence.cost[resourceType] or 0))
                end
            end
            
            -- Show generation
            if next(data.generates) then
                self:Debug("Generates:")
                for resourceType, value in pairs(data.generates) do
                    local resourceName = _G[format("POWER_TYPE_%d", resourceType)] or resourceType
                    self:Debug(format("  %s: %.1f (confidence: %.2f)", 
                        resourceName, value, data.confidence.generates[resourceType] or 0))
                end
            end
            
            -- Show outliers if any
            if data.outliers then
                self:Debug("Outliers:")
                for category, outliers in pairs(data.outliers) do
                    self:Debug(format("  %s: %d outliers", category, #outliers))
                end
            end
        end
    else
        -- Show summary of all learned spells
        self:Debug("|cFF00FFFF===== Learned Costs Summary =====|r")
        local spellCount = 0
        for storedSpellID, spellData in pairs(self:GetChar().compiled) do
            spellCount = spellCount + 1
            local contextCount = 0
            for _ in pairs(spellData) do contextCount = contextCount + 1 end
            
            self:Debug(format("%s (ID: %d) - %d contexts", 
                GetSpellInfo(storedSpellID) or "Unknown",
                storedSpellID,
                contextCount))
        end
        self:Debug(format("\nTotal spells learned: %d", spellCount))
    end
end

--- Check if a spell is usable given a player state
-- @param spellID The spell ID to check
-- @param state Current player state (resources, runes, buffs, etc)
-- @return boolean, string - Is spell usable and reason if not
function PredictionEngine:IsSpellUsable(spellID, state)
    if not state then return false, "No state provided" end
    
    -- Get learned data for this spell
    local spellData = self:GetChar().compiled[spellID]
    if not spellData then return false, "No learned data for spell" end
    
    -- Default context if none matches current state
    local contextKey = self:GenerateContextKey(state.buffs and state.buffs.player or {})
    local spellContext = spellData[contextKey] or spellData["default"]
    
    if not spellContext then return false, "No context data found" end
    
    -- Initialize tables if they don't exist
    spellContext.cost = spellContext.cost or {}
    spellContext.generates = spellContext.generates or {}
    spellContext.applies = spellContext.applies or {}
    spellContext.removes = spellContext.removes or {}
    spellContext.confidence = spellContext.confidence or {}
    
    -- Debug output for spell data
    NAG:Debug("=== Spell Usability Check for " .. (GetSpellInfo(spellID) or "Unknown") .. " (ID: " .. spellID .. ") ===")
    NAG:Debug("Context: " .. contextKey)
    NAG:Debug("Total observations: " .. (spellContext.count or 0))
    
    -- Check resource costs
    if next(spellContext.cost) then
        NAG:Debug("\nResource Requirements:")
        for resourceType, cost in pairs(spellContext.cost) do
            local available = state.resources and state.resources[resourceType] or 0
            local resourceName = _G["POWER_TYPE_" .. resourceType] or resourceType
            NAG:Debug("  " .. resourceName .. ": " .. available .. "/" .. (state.resources and state.resources[resourceType .. "Max"] or 0) .. " (Required: " .. cost .. ")")
            if available < cost then
                return false, "Insufficient " .. resourceName .. ": " .. available .. " < " .. cost
            end
        end
    end
    
    -- Check rune requirements
    if spellContext.runeUsage then
        NAG:Debug("\nRune Requirements:")
        
        -- Get all possible rune combinations from learned data
        local runeCombinations = self:GetLearnedRuneCombinations(spellID)
        if not runeCombinations or #runeCombinations == 0 then
            NAG:Debug("  No rune combinations learned yet")
            return false, "No rune combinations learned"
        end
        
        -- Debug output for learned combinations
        NAG:Debug("  Learned Combinations:")
        for i, combo in ipairs(runeCombinations) do
            local comboStr = {}
            for _, rune in ipairs(combo) do
                local typeStr = rune.type == CONSTANTS.RUNE_TYPE.BLOOD and "Blood" 
                    or rune.type == CONSTANTS.RUNE_TYPE.FROST and "Frost"
                    or rune.type == CONSTANTS.RUNE_TYPE.UNHOLY and "Unholy"
                    or rune.type == CONSTANTS.RUNE_TYPE.DEATH and "Death"
                    or "Unknown"
                table.insert(comboStr, rune.count .. " " .. typeStr)
            end
            NAG:Debug("    " .. i .. ". " .. table.concat(comboStr, " + "))
        end
        
        -- Check if any combination is possible with current runes
        local canCast = false
        local availableRunes = self:GetAvailableRunes(state)
        
        NAG:Debug("\n  Available Runes:")
        for type, count in pairs(availableRunes) do
            local typeStr = type == CONSTANTS.RUNE_TYPE.BLOOD and "Blood" 
                or type == CONSTANTS.RUNE_TYPE.FROST and "Frost"
                or type == CONSTANTS.RUNE_TYPE.UNHOLY and "Unholy"
                or type == CONSTANTS.RUNE_TYPE.DEATH and "Death"
                or "Unknown"
            NAG:Debug("    " .. typeStr .. ": " .. count)
        end
        
        -- Try each combination
        for i, combo in ipairs(runeCombinations) do
            local canUseCombo = true
            for _, rune in ipairs(combo) do
                if (availableRunes[rune.type] or 0) < rune.count then
                    canUseCombo = false
                    break
                end
            end
            if canUseCombo then
                canCast = true
                NAG:Debug("\n  Can cast using combination " .. i)
                break
            end
        end
        
        if not canCast then
            return false, "Insufficient runes for any known combination"
        end
    end
    
    -- Check buff requirements
    if next(spellContext.applies) then
        NAG:Debug("\nBuff Requirements:")
        for buffId, chance in pairs(spellContext.applies) do
            local buffName = GetSpellInfo(buffId) or "Unknown"
            NAG:Debug("  " .. buffName .. " (ID: " .. buffId .. ") - Chance: " .. string.format("%.1f", chance * 100) .. "%")
        end
    end
    
    NAG:Debug("\nSpell is usable!")
    return true, "Spell is usable"
end

--- Get learned rune combinations for a spell
-- @param spellID The spell ID to get combinations for
-- @return table Array of possible rune combinations
function PredictionEngine:GetLearnedRuneCombinations(spellID)
    local spellData = self:GetChar().compiled[spellID]
    if not spellData then return nil end
    
    local combinations = {}
    local seenCombos = {}
    
    -- Process all contexts to find unique combinations
    for contextKey, contextData in pairs(spellData) do
        if contextData.runeUsage and contextData.runeUsage.typePatterns then
            for pattern, count in pairs(contextData.runeUsage.typePatterns) do
                -- Only process if we haven't seen this combination before
                if not seenCombos[pattern] then
                    seenCombos[pattern] = true
                    
                    -- Parse the pattern into a combination
                    local combo = {}
                    for typeStr in pattern:gmatch("%d+") do
                        local runeType = tonumber(typeStr)
                        if runeType then
                            -- Count how many of this type we need
                            local typeCount = 0
                            for _ in pattern:gmatch(typeStr) do
                                typeCount = typeCount + 1
                            end
                            table.insert(combo, {
                                type = runeType,
                                count = typeCount
                            })
                        end
                    end
                    
                    if #combo > 0 then
                        table.insert(combinations, combo)
                    end
                end
            end
        end
    end
    
    return combinations
end

--- Get available runes from current state
-- @param state Current player state
-- @return table Count of available runes by type
function PredictionEngine:GetAvailableRunes(state)
    local available = {
        [CONSTANTS.RUNE_TYPE.BLOOD] = 0,
        [CONSTANTS.RUNE_TYPE.FROST] = 0,
        [CONSTANTS.RUNE_TYPE.UNHOLY] = 0,
        [CONSTANTS.RUNE_TYPE.DEATH] = 0
    }
    
    if state.runes then
        for i = 1, CONSTANTS.MAX_RUNES do
            local rune = state.runes[i]
            if rune and rune.ready then
                available[rune.type] = (available[rune.type] or 0) + 1
            end
        end
    end
    
    return available
end

--- Helper to get/set the correct resource field for a given resourceType
function PredictionEngine:GetResourceField(state, resourceType)
    -- Accepts either a string ("power", "secondary", etc.) or a numeric powerType
    if not state or not state.resources then return nil, nil, nil end
    -- Map string keys
    if resourceType == "power" or resourceType == (state.resources.power and state.resources.power.type) then
        return state.resources.power, "current", state.resources.power.max
    elseif resourceType == "secondary" or resourceType == (state.resources.secondary and state.resources.secondary.type) then
        return state.resources.secondary, "current", state.resources.secondary.max
    elseif resourceType == "balance" and state.resources.balance then
        return state.resources.balance, nil, nil -- Druid eclipse, handled separately
    end
    -- Fallback: try direct numeric match for power/secondary
    if state.resources.power and state.resources.power.type == resourceType then
        return state.resources.power, "current", state.resources.power.max
    elseif state.resources.secondary and state.resources.secondary.type == resourceType then
        return state.resources.secondary, "current", state.resources.secondary.max
    end
    -- Fallback: try direct field
    if state.resources[resourceType] then
        return state.resources[resourceType], "current", state.resources[resourceType].max
    end
    return nil, nil, nil
end

--- Simulate the effects of casting a spell
-- @param spellID The spell ID to simulate
-- @param state Current player state (optional)
-- @return table, string - New state after spell cast, or nil and error message if spell cannot be cast
function PredictionEngine:SimulateSpellCast(spellID, state)
    -- If no state provided, fetch current state
    if not state then
        if self.stateManager and self.stateManager.CaptureCurrentState then
            state = self.stateManager:CaptureCurrentState()
        else
            return nil, "No state provided and cannot fetch current state"
        end
    end
    -- First check if spell is usable
    local isUsable, reason = self:IsSpellUsable(spellID, state)
    if not isUsable then
        return nil, reason
    end
    -- Create a copy of the state to modify
    local newState = self:DeepCopy(state)
    -- Get spell data
    local spellData = self:GetChar().compiled[spellID]
    local contextKey = self:GenerateContextKey(state.buffs and state.buffs.player or {})
    local spellContext = spellData[contextKey] or spellData["default"]
    -- Apply resource costs (subtract before generation)
    if spellContext.cost then
        for resourceType, amount in pairs(spellContext.cost) do
            local resTable, resKey, resMax = self:GetResourceField(newState, resourceType)
            if resTable and resKey then
                local oldValue = resTable[resKey] or 0
                local newValue = math.max(oldValue - amount, 0)
                resTable[resKey] = newValue
                NAG:Debug(string.format("  Cost: %s (%s): %d -> %d", tostring(resourceType), tostring(resKey), oldValue, newValue))
            else
                -- Fallback for unknown resource types
                local oldValue = newState.resources[resourceType] or 0
                local newValue = math.max(oldValue - amount, 0)
                newState.resources[resourceType] = newValue
                NAG:Debug(string.format("  Cost (fallback): %s: %d -> %d", tostring(resourceType), oldValue, newValue))
            end
        end
    end
    -- Apply resource generation (add after cost)
    if spellContext.generates then
        for resourceType, amount in pairs(spellContext.generates) do
            local resTable, resKey, resMax = self:GetResourceField(newState, resourceType)
            if resTable and resKey then
                local oldValue = resTable[resKey] or 0
                local newValue = oldValue + amount
                -- Cap at learned maximum if available
                local learnedCap = self:GetGlobal().resourceCaps[resourceType] or resMax
                if learnedCap then newValue = math.min(newValue, learnedCap) end
                resTable[resKey] = newValue
                NAG:Debug(string.format("  Generates: %s (%s): %d -> %d", tostring(resourceType), tostring(resKey), oldValue, newValue))
            else
                local oldValue = newState.resources[resourceType] or 0
                local newValue = oldValue + amount
                local learnedCap = self:GetGlobal().resourceCaps[resourceType]
                if learnedCap then newValue = math.min(newValue, learnedCap) end
                newState.resources[resourceType] = newValue
                NAG:Debug(string.format("  Generates (fallback): %s: %d -> %d", tostring(resourceType), oldValue, newValue))
            end
        end
    end
    -- Apply rune changes with pattern prioritization
    if spellContext.runeUsage then
        NAG:Debug("\nRune Changes:")
        
        -- Get all rune patterns sorted by frequency
        local sortedPatterns = {}
        if spellContext.runeUsage.typePatterns then
            for pattern, count in pairs(spellContext.runeUsage.typePatterns) do
                table.insert(sortedPatterns, {pattern = pattern, count = count})
            end
            table.sort(sortedPatterns, function(a, b) return a.count > b.count end)
        end
        
        -- Debug current rune patterns
        NAG:Debug("Available Rune Patterns (in priority order):")
        for _, patternData in ipairs(sortedPatterns) do
            NAG:Debug(format("  Pattern: %s (seen %d times)", 
                patternData.pattern, patternData.count))
        end
        
        -- Get all available runes by type
        local availableRunes = {
            [CONSTANTS.RUNE_TYPE.BLOOD] = {},
            [CONSTANTS.RUNE_TYPE.FROST] = {},
            [CONSTANTS.RUNE_TYPE.UNHOLY] = {},
            [CONSTANTS.RUNE_TYPE.DEATH] = {}
        }
        
        -- Map available runes
        for i = 1, 6 do
            local rune = newState.runes[i]
            if rune and rune.ready then
                table.insert(availableRunes[rune.type], i)
            end
        end
        
        -- Try patterns in order of frequency
        local runeIndices = nil
        for _, patternData in ipairs(sortedPatterns) do
            local pattern = patternData.pattern
            local runeTypes = {strsplit(",", pattern)}
            local tempIndices = {}
            local canUsePattern = true
            
            -- Try to match this pattern
            for _, runeTypeStr in ipairs(runeTypes) do
                local runeType = tonumber(runeTypeStr)
                -- Try primary rune type
                if #availableRunes[runeType] > 0 then
                    table.insert(tempIndices, table.remove(availableRunes[runeType], 1))
                -- Try death rune as fallback
                elseif #availableRunes[CONSTANTS.RUNE_TYPE.DEATH] > 0 then
                    table.insert(tempIndices, table.remove(availableRunes[CONSTANTS.RUNE_TYPE.DEATH], 1))
                else
                    canUsePattern = false
                    -- Return runes we temporarily removed
                    for _, index in ipairs(tempIndices) do
                        local returnedRune = newState.runes[index]
                        table.insert(availableRunes[returnedRune.type], index)
                    end
                    break
                end
            end
            
            if canUsePattern then
                runeIndices = tempIndices
                NAG:Debug(format("Using pattern: %s (priority pattern)", pattern))
                break
            end
        end
        
        -- If no pattern worked, try any available runes as last resort
        if not runeIndices then
            runeIndices = {}
            local neededRunes = spellContext.runeUsage.mostCommonRuneCount or 2
            
            -- Try to use non-death runes first
            for runeType, indices in pairs(availableRunes) do
                if runeType ~= CONSTANTS.RUNE_TYPE.DEATH then
                    while #runeIndices < neededRunes and #indices > 0 do
                        table.insert(runeIndices, table.remove(indices, 1))
                    end
                end
            end
            
            -- Use death runes if needed
            while #runeIndices < neededRunes and #availableRunes[CONSTANTS.RUNE_TYPE.DEATH] > 0 do
                table.insert(runeIndices, table.remove(availableRunes[CONSTANTS.RUNE_TYPE.DEATH], 1))
            end
            
            if #runeIndices > 0 then
                NAG:Debug("Using fallback rune selection")
            end
        end
        
        -- Apply rune usage
        if runeIndices then
            for _, runeIndex in ipairs(runeIndices) do
                local rune = newState.runes[runeIndex]
                local typeStr = rune.type == CONSTANTS.RUNE_TYPE.BLOOD and "Blood" 
                    or rune.type == CONSTANTS.RUNE_TYPE.FROST and "Frost"
                    or rune.type == CONSTANTS.RUNE_TYPE.UNHOLY and "Unholy"
                    or rune.type == CONSTANTS.RUNE_TYPE.DEATH and "Death"
                    or "Unknown"
                NAG:Debug(format("  Using Rune %d (%s)", runeIndex, typeStr))
                newState.runes[runeIndex].ready = false
                newState.runes[runeIndex].timeLeft = 10  -- Standard rune cooldown
            end
        else
            return nil, "Could not find valid rune combination"
        end
    end
    
    -- Apply buff changes (need to distinguish between reliable and proc-based)
    if spellContext.applies then
        NAG:Debug("\nBuff Applications:")
        newState.buffs = newState.buffs or {}
        newState.buffs.player = newState.buffs.player or {}
        for buffId, chance in pairs(spellContext.applies) do
            local buffName = GetSpellInfo(buffId) or buffId
            local chancePercent = chance * 100
            if chance > 0.7 then
                newState.buffs.player[buffId] = true
                NAG:Debug(format("  Applied: %s (%.1f%% chance - simulating as applied)", buffName, chancePercent))
            else
                NAG:Debug(format("  Skipped: %s (%.1f%% chance - simulating as NOT applied)", buffName, chancePercent))
            end
        end
    end
    -- Apply buff removals (need to distinguish between reliable and proc-based)
    if spellContext.removes then
        NAG:Debug("\nBuff Removals:")
        for buffId, chance in pairs(spellContext.removes) do
            local buffName = GetSpellInfo(buffId) or buffId
            local chancePercent = chance * 100
            if chance > 0.3 and newState.buffs and newState.buffs.player then
                newState.buffs.player[buffId] = nil
                NAG:Debug(format("  Removed: %s (%.1f%% chance - simulating as removed)", buffName, chancePercent))
            else
                NAG:Debug(format("  Skipped: %s (%.1f%% chance - simulating as NOT removed)", buffName, chancePercent))
            end
        end
    end
    
    -- Print final state with detailed resource info
    NAG:Debug("\n=== FINAL STATE ===")
    NAG:Debug("Resources:")
    if newState.resources then
        -- Print primary resource if present
        if newState.resources.power and newState.resources.power.type ~= nil then
            local resourceType = newState.resources.power.type
            local resourceName = _G[format("POWER_TYPE_%d", resourceType)] or tostring(resourceType)
            local current = newState.resources.power.current or 0
            local max = newState.resources.power.max or 0
            NAG:Debug(format("  %s (%d): %d/%d", resourceName, resourceType, current, max))
        end
        -- Print secondary resource if present and valid
        if newState.resources.secondary and newState.resources.secondary.type ~= nil then
            local resourceType = newState.resources.secondary.type
            local resourceName = _G[format("POWER_TYPE_%d", resourceType)] or tostring(resourceType)
            local current = newState.resources.secondary.current or 0
            local max = newState.resources.secondary.max or 0
            NAG:Debug(format("  %s (%d): %d/%d", resourceName, resourceType, current, max))
        end
        -- Print any other resources (e.g., balance for druids, or custom fields)
        for k, v in pairs(newState.resources) do
            if type(v) == "table" and k ~= "power" and k ~= "secondary" then
                -- Try to print as resource if it has .current
                if v.current ~= nil then
                    local resourceName = tostring(k)
                    local current = v.current or 0
                    local max = v.max or 0
                    NAG:Debug(format("  %s: %d/%d", resourceName, current, max))
                elseif v.solar or v.lunar then
                    -- Special case for druid balance
                    NAG:Debug(format("  Balance (solar): %d", v.solar or 0))
                    NAG:Debug(format("  Balance (lunar): %d", v.lunar or 0))
                end
            end
        end
    end
    
    NAG:Debug("\nRunes:")
    for i = 1, 6 do
        local rune = newState.runes[i]
        if rune then
            local typeStr = rune.type == CONSTANTS.RUNE_TYPE.BLOOD and "Blood" 
                or rune.type == CONSTANTS.RUNE_TYPE.FROST and "Frost"
                or rune.type == CONSTANTS.RUNE_TYPE.UNHOLY and "Unholy"
                or rune.type == CONSTANTS.RUNE_TYPE.DEATH and "Death"
                or "Unknown"
            NAG:Debug(format("  Rune %d (%s): %s", i, typeStr, rune.ready and "Ready" or format("CD: %.1f", rune.timeLeft)))
        end
    end
    
    NAG:Debug("\nActive Buffs:")
    if newState.buffs and newState.buffs.player then
        for buffId in pairs(newState.buffs.player) do
            NAG:Debug(format("  %s (ID: %d)", GetSpellInfo(buffId) or "Unknown", buffId))
        end
    else
        NAG:Debug("  None")
    end
    
    NAG:Debug("\nSimulation complete!")
    return newState, "Spell cast simulated successfully"
end

--- Deep copy a table
function PredictionEngine:DeepCopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[self:DeepCopy(orig_key)] = self:DeepCopy(orig_value)
        end
        setmetatable(copy, self:DeepCopy(getmetatable(orig)))
    else
        copy = orig
    end
    return copy
end

--- Register prediction-related slash commands
function PredictionEngine:RegisterPredictionCommands()
    -- Command to check if a spell is usable
    self:RegisterChatCommand("nagcheck", function(input)
        if not input or input == "" then
            self:Debug("Usage: /nagcheck spellID")
            return
        end
        
        local spellID = tonumber(input)
        if not spellID then
            self:Debug("Invalid spell ID")
            return
        end
        
        local state = self.stateManager:CaptureCurrentState()
        local isUsable, reason = self:IsSpellUsable(spellID, state)
        
        self:Debug("=== Spell Usability Check ===")
        self:Debug(string.format("Spell: %s (ID: %d)", GetSpellInfo(spellID) or "Unknown", spellID))
        self:Debug(string.format("Usable: %s", isUsable and "Yes" or "No"))
        self:Debug(string.format("Reason: %s", reason))
    end)
    
    -- Command to simulate a spell cast
    self:RegisterChatCommand("nagsim", function(input)
        if not input or input == "" then
            self:Debug("Usage: /nagsim spellID")
            return
        end
        
        local spellID = tonumber(input)
        if not spellID then
            self:Debug("Invalid spell ID")
            return
        end
        
        local currentState = self.stateManager:CaptureCurrentState()
        local newState, result = self:SimulateSpellCast(spellID, currentState)
        
        self:Debug("=== Spell Cast Simulation ===")
        self:Debug(string.format("Spell: %s (ID: %d)", GetSpellInfo(spellID) or "Unknown", spellID))
        
        if not newState then
            self:Debug(string.format("Simulation failed: %s", result))
            return
        end
        
        -- Print resource changes
        self:Debug("Resource Changes:")
        for resourceType, newValue in pairs(newState.resources or {}) do
            local oldValue = currentState.resources and currentState.resources[resourceType] or 0
            if newValue ~= oldValue then
                self:Debug(string.format("  %s: %d -> %d", 
                    _G[format("POWER_TYPE_%d", resourceType)] or resourceType,
                    oldValue, newValue))
            end
        end
        
        -- Print rune changes
        if newState.runes then
            self:Debug("Rune Changes:")
            for i = 1, 6 do
                local oldRune = currentState.runes[i]
                local newRune = newState.runes[i]
                if oldRune.ready ~= newRune.ready then
                    self:Debug(string.format("  Rune %d: %s -> %s", 
                        i,
                        oldRune.ready and "Ready" or string.format("CD: %.1f", oldRune.timeLeft),
                        newRune.ready and "Ready" or string.format("CD: %.1f", newRune.timeLeft)))
                end
            end
        end
        
        -- Print buff changes
        if newState.buffs and newState.buffs.player then
            local oldBuffs = currentState.buffs and currentState.buffs.player or {}
            local newBuffs = newState.buffs.player
            
            local changes = false
            self:Debug("Buff Changes:")
            
            -- Check for gained buffs
            for buffId in pairs(newBuffs) do
                if not oldBuffs[buffId] then
                    changes = true
                    self:Debug(string.format("  Gained: %s", GetSpellInfo(buffId) or buffId))
                end
            end
            
            -- Check for lost buffs
            for buffId in pairs(oldBuffs) do
                if not newBuffs[buffId] then
                    changes = true
                    self:Debug(string.format("  Lost: %s", GetSpellInfo(buffId) or buffId))
                end
            end
            
            if not changes then
                self:Debug("  No changes")
            end
        end
    end)
end

--- Clear all learned data
function PredictionEngine:ClearLearnedData()
    -- Clear only the processed/learned data
    if self:GetChar().compiled then
        wipe(self:GetChar().compiled)
    end
    
    -- Clear processed history
    if self:GetChar().processedHistory then
        wipe(self:GetChar().processedHistory)
    end
    
    -- Clear spell effects (learned relationships)
    if self.stateManager and self.stateManager.state then
        self.stateManager.state.spellEffects = {}
        self.stateManager.state.activeBuffs = {}
    end
    
    -- DO NOT clear spellChanges as it contains raw cast records
    -- if self.stateManager and self.stateManager.db.global.spellChanges then
    --     wipe(self.stateManager.db.global.spellChanges)
    -- end
    
    self:Debug("All processed/learned data has been cleared")
    self:Debug("Raw spell cast records have been preserved")
    self:Debug("Use /nagprocess to reprocess the existing cast records")
end 

-- Add new function to track resource caps
function PredictionEngine:UpdateResourceCaps(state)
    if not state or not state.resources then return end
    
    -- Initialize if needed
    if not self:GetGlobal().resourceCaps then
        self:GetGlobal().resourceCaps = {}
    end
    if not self:GetGlobal().resourceCapHistory then
        self:GetGlobal().resourceCapHistory = {}
    end
    
    -- Track each resource type
    for resourceType, value in pairs(state.resources) do
        -- Skip "Max" entries
        if not string.match(tostring(resourceType), "Max$") then
            -- Get the current max value
            local maxKey = tostring(resourceType) .. "Max"
            local currentMax = state.resources[maxKey]
            
            if currentMax and currentMax > 0 then
                -- Initialize history for this resource type
                if not self:GetGlobal().resourceCapHistory[resourceType] then
                    self:GetGlobal().resourceCapHistory[resourceType] = {}
                end
                
                -- Add to history
                table.insert(self:GetGlobal().resourceCapHistory[resourceType], currentMax)
                
                -- Keep history manageable
                while #self:GetGlobal().resourceCapHistory[resourceType] > 100 do
                    table.remove(self:GetGlobal().resourceCapHistory[resourceType], 1)
                end
                
                -- Update the learned cap (use most common value)
                local capCounts = {}
                local maxCount = 0
                local mostCommonCap = currentMax
                
                for _, cap in ipairs(self:GetGlobal().resourceCapHistory[resourceType]) do
                    capCounts[cap] = (capCounts[cap] or 0) + 1
                    if capCounts[cap] > maxCount then
                        maxCount = capCounts[cap]
                        mostCommonCap = cap
                    end
                end
                
                -- Update the learned cap
                self:GetGlobal().resourceCaps[resourceType] = mostCommonCap
                
                -- Debug output for cap changes
                if self:GetGlobal().debugMode and (not self:GetGlobal().resourceCaps[resourceType] or self:GetGlobal().resourceCaps[resourceType] ~= mostCommonCap) then
                    self:Debug(format("Updated resource cap for type %d: %d", resourceType, mostCommonCap))
                end
            end
        end
    end
end

--- Create frames for prediction chain visualization
function PredictionEngine:CreatePredictionFrames()
    -- Only create frames if we have learned data
    if not self:GetChar().compiled or not next(self:GetChar().compiled) then
        return
    end
    
    -- Create main container frame
    self.predictionFrame = CreateFrame("Frame", "NAGPredictionChainFrame", UIParent)
    self.predictionFrame:SetSize(200, 50)  -- Will be adjusted based on number of predictions
    self.predictionFrame:SetPoint("TOP", UIParent, "CENTER", 0, 100)  -- Position above center
    self.predictionFrame:SetMovable(true)
    self.predictionFrame:EnableMouse(true)
    self.predictionFrame:RegisterForDrag("LeftButton")
    self.predictionFrame:SetScript("OnDragStart", self.predictionFrame.StartMoving)
    self.predictionFrame:SetScript("OnDragStop", self.predictionFrame.StopMovingOrSizing)
    
    -- Create background
    self.predictionFrame.bg = self.predictionFrame:CreateTexture(nil, "BACKGROUND")
    self.predictionFrame.bg:SetAllPoints()
    self.predictionFrame.bg:SetColorTexture(0, 0, 0, 0.7)
    
    -- Create prediction slots (up to 5 steps ahead)
    self.predictionSlots = {}
    local slotSize = 40
    local spacing = 5
    
    for i = 1, 5 do
        local slot = CreateFrame("Frame", nil, self.predictionFrame)
        slot:SetSize(slotSize, slotSize)
        slot:SetPoint("LEFT", (i-1) * (slotSize + spacing), 0)
        
        -- Create spell icon
        slot.icon = slot:CreateTexture(nil, "ARTWORK")
        slot.icon:SetAllPoints()
        
        -- Create cooldown frame
        slot.cooldown = CreateFrame("Cooldown", nil, slot, "CooldownFrameTemplate")
        slot.cooldown:SetAllPoints()
        
        -- Create resource cost text
        slot.costText = slot:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
        slot.costText:SetPoint("BOTTOM", 0, -15)
        
        -- Create resource gain text
        slot.gainText = slot:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
        slot.gainText:SetPoint("TOP", 0, 15)
        
        -- Create state preview frame (shown on hover)
        slot.preview = CreateFrame("Frame", nil, slot, "BackdropTemplate")
        slot.preview:SetSize(200, 100)
        slot.preview:SetPoint("TOP", slot, "BOTTOM", 0, -5)
        slot.preview:SetBackdrop({
            bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background",
            edgeFile = "Interface\\DialogFrame\\UI-DialogBox-Border",
            tile = true,
            tileSize = 32,
            edgeSize = 32,
            insets = { left = 11, right = 12, top = 12, bottom = 11 }
        })
        slot.preview:Hide()
        
        -- Add hover functionality
        slot:SetScript("OnEnter", function()
            slot.preview:Show()
        end)
        slot:SetScript("OnLeave", function()
            slot.preview:Hide()
        end)
        
        self.predictionSlots[i] = slot
    end
    
    -- Hide the frame initially
    self.predictionFrame:Hide()
end

--- Update the prediction chain visualization
function PredictionEngine:UpdatePredictionChain()
    -- Check if we have any learned spell data
    if not self:GetChar().compiled or not next(self:GetChar().compiled) then
        -- Use throttled debug to avoid spam
        self:ThrottledDebug("|cFFFF0000No learned spell data available yet|r", "no_spell_data", 30)
        self:ThrottledDebug("Use /nagprocess to process collected spell data", "nagprocess_hint", 30)
        
        if self.predictionFrame then
            self.predictionFrame:Hide()
        end
        return
    end
    
    -- Create frame if it doesn't exist
    if not self.predictionFrame then
        self:CreatePredictionFrames()
    end
    
    -- Get current state
    local currentState = self.stateManager:CaptureCurrentState()
    
    -- Get next action from NAG
    local nextAction = NAG.nextSpell
    if not nextAction then
        -- Use throttled debug to avoid spam
        self:ThrottledDebug("|cFFFF0000No next action available from NAG|r", "no_next_action", 30)
        self.predictionFrame:Hide()
        return
    end
    
    -- Show the frame
    self.predictionFrame:Show()
    
    -- Clear existing predictions
    for _, slot in ipairs(self.predictionSlots) do
        slot.icon:SetTexture(nil)
        slot.cooldown:Hide()
        slot.costText:SetText("")
        slot.gainText:SetText("")
    end
    
    -- Start prediction chain
    local currentPredictionState = currentState
    local predictions = {}
    local unlearnedSpells = {}
    
    if self:GetGlobal().debugMode then
        self:Debug("|cFF00FFFF=== Starting Prediction Chain ===")
        self:Debug(format("Initial state - Resources:"))
        for resource, amount in pairs(currentState.resources) do
            self:Debug(format("  %s: %d", resource, amount))
        end
        if currentState.buffs and currentState.buffs.player then
            self:Debug("Active buffs:")
            for buffId in pairs(currentState.buffs.player) do
                self:Debug(format("  %s", GetSpellInfo(buffId) or buffId))
            end
        end
    end
    
    -- Generate prediction chain
    for i = 1, #self.predictionSlots do
        -- Get next action based on current prediction state
        local nextSpell = self:GetNextPredictedAction(currentPredictionState)
        if not nextSpell then 
            if self:GetGlobal().debugMode then
                self:Debug(format("|cFFFF0000No next action predicted at step %d|r", i))
            end
            break 
        end
        
        -- Check if we have data for this spell
        if not self:GetChar().compiled[nextSpell] then
            if self:GetGlobal().debugMode then
                self:Debug(format("|cFFFF0000Spell not learned: %s (ID: %d)|r", 
                    GetSpellInfo(nextSpell) or "Unknown", nextSpell))
            end
            table.insert(unlearnedSpells, nextSpell)
            break
        end
        
        -- Store prediction
        predictions[i] = {
            spellID = nextSpell,
            state = currentPredictionState
        }
        
        if self:GetGlobal().debugMode then
            self:Debug(format("|cFF00FFFFStep %d: %s (ID: %d)|r", 
                i, GetSpellInfo(nextSpell) or "Unknown", nextSpell))
        end
        
        -- Update slot visualization
        local slot = self.predictionSlots[i]
        
        -- Set icon
        slot.icon:SetTexture(GetSpellTexture(nextSpell))
        
        -- Get spell data from compiled data
        local spellData = self:GetChar().compiled[nextSpell]
        if spellData then
            -- Get the most common context or default
            local contextKey = self:GenerateContextKey(currentPredictionState.buffs and currentPredictionState.buffs.player or {})
            local contextData = spellData[contextKey] or spellData["default"]
            
            if contextData then
                -- Set cost text
                if contextData.cost then
                    local costText = ""
                    for resource, amount in pairs(contextData.cost) do
                        if costText ~= "" then costText = costText .. ", " end
                        costText = costText .. amount .. " " .. resource
                    end
                    slot.costText:SetText(costText)
                    if self:GetGlobal().debugMode then
                        self:Debug(format("  Cost: %s", costText))
                    end
                end
                
                -- Set gain text
                if contextData.generates then
                    local gainText = ""
                    for resource, amount in pairs(contextData.generates) do
                        if gainText ~= "" then gainText = gainText .. ", " end
                        gainText = gainText .. "+" .. amount .. " " .. resource
                    end
                    slot.gainText:SetText(gainText)
                    if self:GetGlobal().debugMode then
                        self:Debug(format("  Generates: %s", gainText))
                    end
                end
            end
        end
        
        -- Update preview with state information
        self:UpdateSlotPreview(slot, currentPredictionState, nextSpell)
        
        -- Apply spell effects to get next state
        currentPredictionState = self:ApplySpellEffects(nextSpell, currentPredictionState)
        
        if self:GetGlobal().debugMode then
            self:Debug("State after cast:")
            for resource, amount in pairs(currentPredictionState.resources) do
                self:Debug(format("  %s: %d", resource, amount))
            end
            if currentPredictionState.buffs and currentPredictionState.buffs.player then
                self:Debug("Active buffs:")
                for buffId in pairs(currentPredictionState.buffs.player) do
                    self:Debug(format("  %s", GetSpellInfo(buffId) or buffId))
                end
            end
        end
    end
    
    -- Store predictions for reference
    self.state.predictions = predictions
    
    -- If we found unlearned spells, show a message
    if #unlearnedSpells > 0 then
        local unlearnedList = {}
        for _, spellID in ipairs(unlearnedSpells) do
            table.insert(unlearnedList, format("%s (ID: %d)", GetSpellInfo(spellID) or "Unknown", spellID))
        end
        
        if self:GetGlobal().debugMode then
            self:Debug("|cFFFF0000=== Unlearned Spells ===")
            self:Debug("The following spells need to be learned:")
            for _, spellInfo in ipairs(unlearnedList) do
                self:Debug(format("  %s", spellInfo))
            end
            self:Debug("Use /nagprocess to learn these spells")
        end
    end
    
    if self:GetGlobal().debugMode then
        self:Debug("|cFF00FFFF=== Prediction Chain Complete ===")
        self:Debug(format("Generated %d predictions", #predictions))
    end
end

--- Update the preview frame for a prediction slot
function PredictionEngine:UpdateSlotPreview(slot, state, spellID)
    if not slot.preview then return end
    
    -- Clear existing preview content
    local children = {slot.preview:GetChildren()}
    for _, child in ipairs(children) do
        child:Hide()
    end
    
    -- Create new preview content
    local yOffset = -10
    local lineHeight = 15
    
    -- Get spell data
    local spellData = self:GetChar().compiled[spellID]
    if spellData then
        -- Get the most common context or default
        local contextKey = self:GenerateContextKey(state.buffs and state.buffs.player or {})
        local contextData = spellData[contextKey] or spellData["default"]
        
        if contextData then
            -- Show confidence level
            local confidenceText = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
            confidenceText:SetPoint("TOPLEFT", 10, yOffset)
            local confidence = contextData.confidence and contextData.confidence.overall or 0
            local confidenceColor = confidence > 0.8 and "|cFF00FF00" or confidence > 0.5 and "|cFFFFFF00" or "|cFFFF0000"
            confidenceText:SetText(format("Confidence: %s%.1f%%|r", confidenceColor, confidence * 100))
            yOffset = yOffset - lineHeight
            
            -- Show costs
            if contextData.cost and next(contextData.cost) then
                local costText = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                costText:SetPoint("TOPLEFT", 10, yOffset)
                costText:SetText("Costs:")
                yOffset = yOffset - lineHeight
                
                for resource, amount in pairs(contextData.cost) do
                    local resourceText = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                    resourceText:SetPoint("TOPLEFT", 20, yOffset)
                    local resourceName = _G[format("POWER_TYPE_%d", resource)] or tostring(resource)
                    resourceText:SetText(format("  %s: %d", resourceName, amount))
                    yOffset = yOffset - lineHeight
                end
            end
            
            -- Show resource generation
            if contextData.generates and next(contextData.generates) then
                local generateText = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                generateText:SetPoint("TOPLEFT", 10, yOffset)
                generateText:SetText("Generates:")
                yOffset = yOffset - lineHeight
                
                for resource, amount in pairs(contextData.generates) do
                    local resourceText = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                    resourceText:SetPoint("TOPLEFT", 20, yOffset)
                    local resourceName = _G[format("POWER_TYPE_%d", resource)] or tostring(resource)
                    resourceText:SetText(format("  %s: +%d", resourceName, amount))
                    yOffset = yOffset - lineHeight
                end
            end
            
            -- Show buff applications
            if contextData.applies and next(contextData.applies) then
                local appliesText = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                appliesText:SetPoint("TOPLEFT", 10, yOffset)
                appliesText:SetText("Applies:")
                yOffset = yOffset - lineHeight
                
                for buffId, chance in pairs(contextData.applies) do
                    local buffText = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                    buffText:SetPoint("TOPLEFT", 20, yOffset)
                    local buffName = GetSpellInfo(buffId) or format("Buff %d", buffId)
                    local chanceColor = chance > 0.8 and "|cFF00FF00" or chance > 0.5 and "|cFFFFFF00" or "|cFFFF0000"
                    buffText:SetText(format("  %s: %s%.1f%%|r", buffName, chanceColor, chance * 100))
                    yOffset = yOffset - lineHeight
                end
            end
            
            -- Show buff removals
            if contextData.removes and next(contextData.removes) then
                local removesText = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                removesText:SetPoint("TOPLEFT", 10, yOffset)
                removesText:SetText("Removes:")
                yOffset = yOffset - lineHeight
                
                for buffId, chance in pairs(contextData.removes) do
                    local buffText = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                    buffText:SetPoint("TOPLEFT", 20, yOffset)
                    local buffName = GetSpellInfo(buffId) or format("Buff %d", buffId)
                    local chanceColor = chance > 0.8 and "|cFF00FF00" or chance > 0.5 and "|cFFFFFF00" or "|cFFFF0000"
                    buffText:SetText(format("  %s: %s%.1f%%|r", buffName, chanceColor, chance * 100))
                    yOffset = yOffset - lineHeight
                end
            end
            
            -- Show rune usage for DKs
            if contextData.runeUsage then
                local runeText = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                runeText:SetPoint("TOPLEFT", 10, yOffset)
                runeText:SetText("Rune Usage:")
                yOffset = yOffset - lineHeight
                
                -- Show most common rune pattern
                if contextData.runeUsage.typePatterns then
                    local mostCommonPattern = nil
                    local highestCount = 0
                    
                    for pattern, count in pairs(contextData.runeUsage.typePatterns) do
                        if count > highestCount then
                            highestCount = count
                            mostCommonPattern = pattern
                        end
                    end
                    
                    if mostCommonPattern then
                        local patternText = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                        patternText:SetPoint("TOPLEFT", 20, yOffset)
                        patternText:SetText(format("  Pattern: %s (%.1f%%)", 
                            mostCommonPattern, 
                            (highestCount / contextData.count) * 100))
                        yOffset = yOffset - lineHeight
                    end
                end
            end
            
            -- Add separator
            yOffset = yOffset - lineHeight
        end
    end
    
    -- Show current state
    local stateText = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
    stateText:SetPoint("TOPLEFT", 10, yOffset)
    stateText:SetText("Current State:")
    yOffset = yOffset - lineHeight
    
    -- Show resources
    if state.resources then
        -- Primary resource
        if state.resources.power then
            local text = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
            text:SetPoint("TOPLEFT", 20, yOffset)
            local resourceName = _G[format("POWER_TYPE_%d", state.resources.power.type)] or "Power"
            text:SetText(format("  %s: %d/%d", resourceName, state.resources.power.current or 0, state.resources.power.max or 0))
            yOffset = yOffset - lineHeight
        end
        
        -- Secondary resource
        if state.resources.secondary then
            local text = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
            text:SetPoint("TOPLEFT", 20, yOffset)
            local resourceName = _G[format("POWER_TYPE_%d", state.resources.secondary.type)] or "Secondary"
            text:SetText(format("  %s: %d/%d", resourceName, state.resources.secondary.current or 0, state.resources.secondary.max or 0))
            yOffset = yOffset - lineHeight
        end
    end
    
    -- Show active buffs
    if state.buffs then
        -- Player buffs
        if state.buffs.player then
            for buffID, buff in pairs(state.buffs.player) do
                if type(buff) == "table" and buff.remaining and buff.remaining > 0 then
                    local text = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                    text:SetPoint("TOPLEFT", 20, yOffset)
                    local buffName = GetSpellInfo(buffID) or format("Buff %d", buffID)
                    local stacks = buff.stacks and buff.stacks > 1 and format(" (%d)", buff.stacks) or ""
                    text:SetText(format("  %s%s: %.1fs", buffName, stacks, buff.remaining))
                    yOffset = yOffset - lineHeight
                end
            end
        end
    end
    
    -- Show rune state for Death Knights
    if state.runes then
        local runeTypes = {
            [1] = "Blood",
            [2] = "Frost",
            [3] = "Unholy",
            [4] = "Death"
        }
        
        local runeCounts = {}
        for i = 1, 6 do
            local rune = state.runes[i]
            if rune and rune.type then
                runeCounts[rune.type] = (runeCounts[rune.type] or 0) + (rune.ready and 1 or 0)
            end
        end
        
        for runeType, count in pairs(runeCounts) do
            if count > 0 then
                local text = slot.preview:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
                text:SetPoint("TOPLEFT", 20, yOffset)
                text:SetText(format("  %s Runes: %d", runeTypes[runeType] or "Unknown", count))
                yOffset = yOffset - lineHeight
            end
        end
    end
    
    -- Adjust preview size based on content
    local height = math.abs(yOffset) + 10
    slot.preview:SetHeight(height)
end

--- Get the next predicted action based on current state
function PredictionEngine:GetNextPredictedAction(state)
    -- Use the clean PredictionAPI interface instead of direct function overrides
    if NAG.PredictionAPI then
        return NAG.PredictionAPI:EvaluateState(state)
    else
        -- Use throttled debug to avoid spam
        self:ThrottledDebug("|cFFFF0000PredictionAPI not available! Using direct nextSpell instead.|r", "api_unavailable", 60)
        -- Fallback to direct nextSpell if API not available
        return NAG.nextSpell
    end
end

--- Apply spell effects to a state
function PredictionEngine:ApplySpellEffects(spellID, state)
    -- Use the PredictionAPI to apply spell effects
    if NAG.PredictionAPI then
        return NAG.PredictionAPI:ApplySpellEffects(spellID, state)
    else
        -- Use throttled debug to avoid spam
        self:ThrottledDebug("|cFFFF0000PredictionAPI not available! Cannot apply spell effects.|r", "api_effects_unavailable", 60)
        return state
    end
end

--- Register update events
function PredictionEngine:RegisterUpdateEvents()
    -- Initialize update interval
    self.state.updateInterval = CONSTANTS.THROTTLE_LEVELS.HIGH
    
    -- Update predictions when NAG updates its next action
    -- Hook into NAG's frame update
    if NAG.Frame then
        NAG.Frame:HookScript("OnUpdate", function(_, elapsed)
            -- Only perform checks every half second to avoid excessive throttling checks
            self.timeSinceLastThrottleCheck = (self.timeSinceLastThrottleCheck or 0) + elapsed
            if self.timeSinceLastThrottleCheck >= 0.5 then
                self:UpdateThrottling()
                self.timeSinceLastThrottleCheck = 0
            end
            
            if NAG.nextSpell then
                self:UpdatePredictionChain()
            end
        end)
    end
    
    -- Initial update scheduler with default interval
    self.updateTimer = self:ScheduleRepeatingTimer("UpdatePredictionChain", self.state.updateInterval)
    
    -- Debug output
    if self:GetGlobal().debugMode then
        self:Debug(format("|cFF00FFFF[Throttling] Initial update interval: %.2f|r", self.state.updateInterval))
    end
end

--- Track a prediction for future validation
function PredictionEngine:TrackPrediction(prediction)
    if not self.state.trackedPredictions then
        self.state.trackedPredictions = {}
    end
    
    -- Create a new prediction record
    local predictionRecord = {
        spellID = prediction.spellID,
        predictedTime = GetTime(),
        actualState = nil,
        wasCorrect = nil,
        confidence = 0
    }
    
    -- Copy the state using our pooling system if available
    if NAG.PredictionAPI and prediction.state then
        predictionRecord.predictedState = NAG.PredictionAPI:CreateStateObject()
        
        -- Copy essential state data
        if prediction.state.resources then
            for k, v in pairs(prediction.state.resources) do
                predictionRecord.predictedState.resources[k] = v
            end
        end
        
        if prediction.state.buffs and prediction.state.buffs.player then
            for buffId, buffData in pairs(prediction.state.buffs.player) do
                predictionRecord.predictedState.buffs.player[buffId] = type(buffData) == "table" 
                    and {remaining = buffData.remaining, stacks = buffData.stacks} 
                    or buffData
            end
        end
        
        if prediction.state.cooldowns then
            for spellId, cd in pairs(prediction.state.cooldowns) do
                predictionRecord.predictedState.cooldowns[spellId] = cd
            end
        end
        
        if prediction.state.runes then
            for i = 1, 6 do
                if prediction.state.runes[i] then
                    predictionRecord.predictedState.runes[i] = {
                        type = prediction.state.runes[i].type,
                        ready = prediction.state.runes[i].ready,
                        timeLeft = prediction.state.runes[i].timeLeft
                    }
                end
            end
        end
    else
        -- Fallback to direct copy if API unavailable
        predictionRecord.predictedState = prediction.state and CopyTable(prediction.state) or {}
    end
    
    -- Store the prediction
    table.insert(self.state.trackedPredictions, predictionRecord)
    
    -- Clean up old predictions to avoid memory bloat
    if #self.state.trackedPredictions > 20 then
        -- Recycle the state object if we're using pooling
        local oldPrediction = table.remove(self.state.trackedPredictions, 1)
        if NAG.PredictionAPI then
            if oldPrediction.predictedState then
                NAG.PredictionAPI:RecycleStateObject(oldPrediction.predictedState)
            end
            if oldPrediction.actualState then
                NAG.PredictionAPI:RecycleStateObject(oldPrediction.actualState)
            end
        end
    end
    
    if self:GetGlobal().debugMode then
        self:Debug(format("|cFF00FFFF[TrackPrediction] Tracking prediction for %s (ID: %d)|r", 
            GetSpellInfo(prediction.spellID) or "Unknown", 
            prediction.spellID))
    end
end

--- Validate a prediction against actual cast
function PredictionEngine:ValidatePrediction(actualSpellID, actualState)
    if not self.state.trackedPredictions or #self.state.trackedPredictions == 0 then
        return
    end
    
    -- Get most recent prediction
    local prediction = self.state.trackedPredictions[#self.state.trackedPredictions]
    
    -- Check if spell matches prediction
    local isCorrect = (prediction.spellID == actualSpellID)
    
    -- Calculate accuracy of state prediction
    local stateAccuracy = self:CalculateStateAccuracy(prediction.predictedState, actualState)
    
    -- Update prediction record
    if NAG.PredictionAPI then
        -- Recycle the old actual state if it exists
        if prediction.actualState then
            NAG.PredictionAPI:RecycleStateObject(prediction.actualState)
        end
        
        -- Copy the state using our pooling system
        prediction.actualState = NAG.PredictionAPI:CreateStateObject()
        
        -- Copy essential state data
        if actualState.resources then
            for k, v in pairs(actualState.resources) do
                prediction.actualState.resources[k] = v
            end
        end
        
        if actualState.buffs and actualState.buffs.player then
            for buffId, buffData in pairs(actualState.buffs.player) do
                prediction.actualState.buffs.player[buffId] = type(buffData) == "table" 
                    and {remaining = buffData.remaining, stacks = buffData.stacks} 
                    or buffData
            end
        end
        
        if actualState.cooldowns then
            for spellId, cd in pairs(actualState.cooldowns) do
                prediction.actualState.cooldowns[spellId] = cd
            end
        end
        
        if actualState.runes then
            for i = 1, 6 do
                if actualState.runes[i] then
                    prediction.actualState.runes[i] = {
                        type = actualState.runes[i].type,
                        ready = actualState.runes[i].ready,
                        timeLeft = actualState.runes[i].timeLeft
                    }
                end
            end
        end
    else
        -- Fallback to direct copy if API unavailable
        prediction.actualState = CopyTable(actualState)
    end
    
    prediction.wasCorrect = isCorrect
    prediction.stateAccuracy = stateAccuracy
    prediction.validatedTime = GetTime()
    
    -- Update confidence for this spell
    self:UpdatePredictionConfidence(prediction)
    
    -- Debug output
    if self:GetGlobal().debugMode then
        self:Debug(format("|cFF%s[ValidatePrediction] %s (ID: %d): %s (Accuracy: %.2f%%)|r",
            isCorrect and "00FF00" or "FF0000",
            GetSpellInfo(actualSpellID) or "Unknown",
            actualSpellID,
            isCorrect and "CORRECT" or "INCORRECT",
            stateAccuracy * 100))
    end
    
    return isCorrect, stateAccuracy
end

--- Calculate the accuracy of a state prediction
function PredictionEngine:CalculateStateAccuracy(predictedState, actualState)
    if not predictedState or not actualState then return 0 end
    
    local totalMetrics = 0
    local matchedMetrics = 0
    
    -- Check resources
    if predictedState.resources and actualState.resources then
        for resourceType, predictedValue in pairs(predictedState.resources) do
            if type(predictedValue) == "number" then
                totalMetrics = totalMetrics + 1
                local actualValue = actualState.resources[resourceType]
                if type(actualValue) == "number" then
                    -- Allow for small differences (5% variance)
                    local threshold = math.max(1, actualValue * 0.05)
                    if math.abs(predictedValue - actualValue) <= threshold then
                        matchedMetrics = matchedMetrics + 1
                    end
                end
            end
        end
    end
    
    -- Check player buffs
    if predictedState.buffs and predictedState.buffs.player and 
       actualState.buffs and actualState.buffs.player then
        for buffId in pairs(predictedState.buffs.player) do
            totalMetrics = totalMetrics + 1
            if actualState.buffs.player[buffId] then
                matchedMetrics = matchedMetrics + 1
            end
        end
        
        -- Also check for buffs in actual that weren't predicted
        for buffId in pairs(actualState.buffs.player) do
            if not predictedState.buffs.player[buffId] then
                totalMetrics = totalMetrics + 1
                -- No match here, counted as mismatch
            end
        end
    end
    
    -- Check cooldowns (only check ones that were predicted)
    if predictedState.cooldowns and actualState.cooldowns then
        for spellId, predictedCooldown in pairs(predictedState.cooldowns) do
            if predictedCooldown > 0 then
                totalMetrics = totalMetrics + 1
                local actualCooldown = actualState.cooldowns[spellId] or 0
                -- Allow for timing differences (1 second tolerance)
                if actualCooldown > 0 and math.abs(predictedCooldown - actualCooldown) <= 1 then
                    matchedMetrics = matchedMetrics + 1
                end
            end
        end
    end
    
    -- Check rune state for Death Knights
    if predictedState.runes and actualState.runes then
        for i = 1, 6 do -- Maximum of 6 runes
            if predictedState.runes[i] and actualState.runes[i] then
                totalMetrics = totalMetrics + 1
                -- Compare ready state (not timing, which can vary)
                if predictedState.runes[i].ready == actualState.runes[i].ready then
                    matchedMetrics = matchedMetrics + 1
                end
            end
        end
    end
    
    -- Calculate final accuracy
    return totalMetrics > 0 and (matchedMetrics / totalMetrics) or 0
end

--- Update confidence based on prediction accuracy
function PredictionEngine:UpdatePredictionConfidence(prediction)
    if not prediction or not prediction.wasCorrect then return end
    
    local spellID = prediction.spellID
    local contextKey = "default"
    
    if prediction.predictedState and prediction.predictedState.buffs and
       prediction.predictedState.buffs.player then
        contextKey = self:GenerateContextKey(prediction.predictedState.buffs.player)
    end
    
    -- Get spell data
    local spellData = self:GetChar().compiled[spellID]
    if not spellData then return end
    
    local contextData = spellData[contextKey] or spellData["default"]
    if not contextData then return end
    
    -- Initialize confidence if needed
    contextData.confidence = contextData.confidence or {}
    contextData.confidence.overall = contextData.confidence.overall or 0.5
    
    -- Adjust confidence based on prediction accuracy
    local adjustmentFactor = 0.05 -- Small incremental changes
    
    if prediction.wasCorrect then
        -- Increase confidence for correct predictions
        contextData.confidence.overall = math.min(1.0, 
            contextData.confidence.overall + (adjustmentFactor * prediction.stateAccuracy))
    else
        -- Decrease confidence for incorrect predictions
        contextData.confidence.overall = math.max(0.1,
            contextData.confidence.overall - adjustmentFactor)
    end
    
    -- Store last validation time
    contextData.lastValidated = GetTime()
    
    -- Debug output
    if self:GetGlobal().debugMode then
        self:Debug(format("|cFF%s[UpdateConfidence] %s (ID: %d): %.2f -> %.2f|r",
            prediction.wasCorrect and "00FF00" or "FF9900",
            GetSpellInfo(spellID) or "Unknown",
            spellID,
            (contextData.confidence.overall - (prediction.wasCorrect and adjustmentFactor * prediction.stateAccuracy or -adjustmentFactor)),
            contextData.confidence.overall))
    end
end

--- Update adaptive throttling based on current system performance
-- @return number The new update interval in seconds
function PredictionEngine:UpdateThrottling()
    -- Get current framerate
    local fps = GetFramerate()
    local oldInterval = self.state.updateInterval or CONSTANTS.UPDATE_INTERVAL
    local newInterval = CONSTANTS.THROTTLE_LEVELS.HIGH -- Default to high performance
    
    -- Adjust based on FPS thresholds
    if fps < CONSTANTS.FPS_THRESHOLDS.LOW then
        newInterval = CONSTANTS.THROTTLE_LEVELS.LOW -- Low performance mode
    elseif fps < CONSTANTS.FPS_THRESHOLDS.MEDIUM then
        newInterval = CONSTANTS.THROTTLE_LEVELS.MEDIUM -- Medium performance mode
    end
    
    -- Only update if there's an actual change
    if newInterval ~= oldInterval then
        self.state.updateInterval = newInterval
        
        -- Cancel existing timer if we have one
        if self.updateTimer then
            self:CancelTimer(self.updateTimer)
        end
        
        -- Create new timer with adjusted interval
        self.updateTimer = self:ScheduleRepeatingTimer("UpdatePredictionChain", newInterval)
        
        -- Debug output
        if self:GetGlobal().debugMode then
            self:Debug(format("|cFF00FFFF[Throttling] Adjusted update interval: %.2f -> %.2f (FPS: %.1f)|r", 
                oldInterval, newInterval, fps))
        end
    end
    
    return newInterval
end

--- Validates and synchronizes data between PredictionEngine and StateManager
-- @return boolean True if the data is properly synchronized
function PredictionEngine:ValidateStateManagerIntegration()
    -- Get reference to StateManager
    local StateManager = NAG:GetModule("SpellLearnerStateManager")
    if not StateManager then
        self:Debug("StateManager module not found")
        return false
    end
    
    -- Check if StateManager has spell effect data
    if not StateManager.state or not StateManager.state.spellEffects then
        self:Debug("StateManager has no spell effect data")
        return false
    end
    
    -- Ensure our compiled data table exists
    if not self:GetChar().compiled then
        self:GetChar().compiled = {}
    end
    
    local stateSpellCount = 0
    local compiledSpellCount = 0
    local syncedSpellCount = 0
    
    -- Count spells in each system
    for spellID, _ in pairs(StateManager.state.spellEffects) do
        stateSpellCount = stateSpellCount + 1
    end
    
    for spellID, _ in pairs(self:GetChar().compiled) do
        compiledSpellCount = compiledSpellCount + 1
    end
    
    -- Find spells that exist in StateManager but not in compiled data
    local missingSpells = {}
    for spellID, effectData in pairs(StateManager.state.spellEffects) do
        if not self:GetChar().compiled[spellID] and effectData.totalCasts and effectData.totalCasts > 3 then
            -- Only consider spells cast more than 3 times
            table.insert(missingSpells, spellID)
        end
    end
    
    -- Process missing spells to add them to compiled data
    for _, spellID in ipairs(missingSpells) do
        local effectData = StateManager.state.spellEffects[spellID]
        
        -- Create basic compiled data
        self:GetChar().compiled[spellID] = self:GetChar().compiled[spellID] or {}
        local compiledData = self:GetChar().compiled[spellID]
        
        -- Ensure default context exists
        compiledData["default"] = compiledData["default"] or {}
        local defaultContext = compiledData["default"]
        
        -- Process resource costs if available
        if effectData.resourceChanges then
            defaultContext.cost = defaultContext.cost or {}
            
            for resourceType, stats in pairs(effectData.resourceChanges) do
                if stats.total < 0 and stats.count > 0 then
                    -- Negative change means cost
                    local avgCost = math.abs(stats.total / stats.count)
                    defaultContext.cost[resourceType] = avgCost
                elseif stats.total > 0 and stats.count > 0 then
                    -- Positive change means generation
                    defaultContext.generates = defaultContext.generates or {}
                    local avgGen = stats.total / stats.count
                    defaultContext.generates[resourceType] = avgGen
                end
            end
        end
        
        -- Process buff applications
        if effectData.buffsApplied and next(effectData.buffsApplied) then
            defaultContext.applies = defaultContext.applies or {}
            
            for buffID, count in pairs(effectData.buffsApplied) do
                local chance = count / effectData.totalCasts
                if chance > 0.3 then -- Only include if applied at least 30% of the time
                    defaultContext.applies[buffID] = chance
                end
            end
        end
        
        -- Process buff removals
        if effectData.buffsRemoved and next(effectData.buffsRemoved) then
            defaultContext.removes = defaultContext.removes or {}
            
            for buffID, count in pairs(effectData.buffsRemoved) do
                local chance = count / effectData.totalCasts
                if chance > 0.3 then -- Only include if removed at least 30% of the time
                    defaultContext.removes[buffID] = chance
                end
            end
        end
        
        self:Debug(format("Added missing spell %d to compiled data", spellID))
        syncedSpellCount = syncedSpellCount + 1
    end
    
    self:Debug(format("State spells: %d, Compiled spells: %d, Synced: %d", 
        stateSpellCount, compiledSpellCount, syncedSpellCount))
        
    return true
end

-- Add slash command to verify and sync data
NAG:RegisterChatCommand("nagsync", function()
    local PEngine = NAG:GetModule("PredictionEngine")
    if not PEngine then
        NAG:Print("PredictionEngine module not found")
        return
    end
    
    local result = PEngine:ValidateStateManagerIntegration()
    NAG:Print(format("StateManager integration validation: %s", result and "PASSED" or "FAILED"))
    
    if result then
        NAG:Print("Data synchronization complete. Use /nagdata to inspect the results.")
    else
        NAG:Print("Data synchronization failed. Check debug output for details.")
    end
end)

--- Ensures that compiled spell data is correctly saved to persistent storage
function PredictionEngine:SaveCompiledData()
    -- Get reference to our saved variables database
    if not self:GetChar() then
        self:Debug("SaveCompiledData: No character database found")
        return false
    end
    
    -- Check if we have compiled data to save
    if not self:GetChar().compiled then
        self:Debug("SaveCompiledData: No compiled data to save")
        return false
    end
    
    -- Count before save
    local spellCount = 0
    for _ in pairs(self:GetChar().compiled) do
        spellCount = spellCount + 1
    end
    
    self:Debug(format("SaveCompiledData: Saving %d compiled spells", spellCount))
    
    -- Force DB update (if needed by AceDB)
    if self.db and self.db.RegisterCallback then
        self.db.callbacks:Fire("OnDatabaseShutdown")
    end
    
    return true
end

-- Override OnDisable to save compiled data
local originalOnDisable = PredictionEngine.OnDisable
function PredictionEngine:OnDisable()
    -- Save compiled data before disabling
    self:SaveCompiledData()
    
    if originalOnDisable then
        originalOnDisable(self)
    end
end

-- Add hooks for session end/reload
local persistenceFrame = CreateFrame("Frame")
persistenceFrame:RegisterEvent("PLAYER_LOGOUT")
persistenceFrame:SetScript("OnEvent", function(_, event)
    if event == "PLAYER_LOGOUT" then
        -- Make sure we save on logout
        local PEngine = NAG:GetModule("PredictionEngine")
        if PEngine then
            PEngine:SaveCompiledData()
        end
    end
end)

-- Add a debug command to force save data
NAG:RegisterChatCommand("nagsave", function()
    local PEngine = NAG:GetModule("PredictionEngine")
    local StateManager = NAG:GetModule("SpellLearnerStateManager")
    
    local success1, success2 = false, false
    
    if PEngine then
        success1 = PEngine:SaveCompiledData()
        NAG:Print(format("PredictionEngine data save: %s", success1 and "SUCCESS" or "FAILED"))
    else
        NAG:Print("PredictionEngine module not found")
    end
    
    if StateManager then
        success2 = StateManager:SaveSpellData()
        NAG:Print(format("StateManager data save: %s", success2 and "SUCCESS" or "FAILED"))
    else
        NAG:Print("StateManager module not found")
    end
    
    if success1 or success2 then
        NAG:Print("Data saved successfully. Reload UI to verify persistence.")
    else
        NAG:Print("No data was saved. Try casting some spells first.")
    end
end)

-- Add QueueDataCompilation function to handle data compilation requests
function PredictionEngine:QueueDataCompilation()
    -- If we already have a pending compilation request, don't schedule another
    if self.compilationPending then return end
    
    -- Schedule compilation for next frame to avoid doing it in the middle of combat
    self.compilationPending = true
    C_Timer.After(0.1, function()
        self:CompileSpellData()
        self.compilationPending = false
    end)
end

-- Enhance CompileSpellData to use the comprehensive spell data
function PredictionEngine:CompileSpellData()
    -- Get state manager module
    local StateManager = self:GetModule("SpellLearnerStateManager", true)
    if not StateManager then
        self:Debug("Cannot compile spell data - StateManager module not found")
        return
    end
    
    -- Get the spell data
    local spellData = StateManager:GetChar().spellData
    if not spellData then
        self:Debug("No spell data to compile")
        return
    end
    
    -- Ensure compiled data exists
    self:GetChar().compiled = self:GetChar().compiled or {}
    
    -- Track changes for debugging
    local newEntries = 0
    local updatedEntries = 0
    
    -- Process each spell
    for spellID, data in pairs(spellData) do
        -- Skip invalid entries
        if not spellID or spellID == 0 or type(spellID) ~= "number" then
            self:Debug("Skipping invalid spell ID: " .. tostring(spellID))
        else
            -- Initialize or get existing compiled entry
            if not self:GetChar().compiled[spellID] then
                self:GetChar().compiled[spellID] = {
                    ["default"] = {
                        cost = {},
                        generates = {},
                        applies = {},
                        removes = {},
                        cooldown = 0,
                        durations = {},
                        maxStacks = {},
                        lastUpdated = 0
                    }
                }
                newEntries = newEntries + 1
            else
                updatedEntries = updatedEntries + 1
            end
            
            local compiled = self:GetChar().compiled[spellID]["default"]
            
            -- Update cost information
            if data.costs then
                for resourceType, change in pairs(data.costs) do
                    if change.min and change.min > 0 then
                        -- Use the most consistent cost value (min value if positive)
                        compiled.cost[resourceType] = change.min
                    end
                end
            end
            
            -- Update buff application information
            if data.buffsApplied then
                for buffID, count in pairs(data.buffsApplied) do
                    local confidence = count / (data.totalCasts or 1)
                    if confidence > 0.1 then -- Only include if somewhat reliable
                        compiled.applies[buffID] = confidence
                    end
                end
            end
            
            -- Update debuff application information
            if data.debuffsApplied then
                for debuffID, count in pairs(data.debuffsApplied) do
                    local confidence = count / (data.totalCasts or 1)
                    if confidence > 0.1 then -- Only include if somewhat reliable
                        compiled.applies[debuffID] = confidence
                    end
                end
            end
            
            -- Set cooldown if known
            if data.statistics and data.statistics.cooldown then
                compiled.cooldown = data.statistics.cooldown.avg or 0
            end
            
            -- Update timestamp
            compiled.lastUpdated = GetTime()
        end
    end
    
    -- Debug output
    self:Debug(string.format("Compiled spell data: %d new entries, %d updated entries", 
        newEntries, updatedEntries))
    
    -- Reset threshold for next statistics gathering
    self:GetGlobal().lastCompilation = GetTime()
end