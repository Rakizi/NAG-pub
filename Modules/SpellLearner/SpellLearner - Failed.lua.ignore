--- ============================ HEADER ============================
--[[
    Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)

    This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held
        liable for any damages arising from the use of this software.

    You are free to:
    - Share — copy and redistribute the material in any medium or format
    - Adapt — remix, transform, and build upon the material

    Under the following terms:
    - Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were
        made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or
        your use.
    - NonCommercial — You may not use the material for commercial purposes.

    Full license text: https://creativecommons.org/licenses/by-nc/4.0/legalcode

    Author: Rakizi: farendil2020@gmail.com @rakizi http://discord.gg/ebonhold
    Date: 06/01/2024

    STATUS: Development
    NOTES: Base module for SpellLearner system - Reworked implementation based on architectural principles
           - Separation of Concerns: Each module has a single, well-defined responsibility
           - Data Flow Architecture: Unidirectional data flow with clear boundaries
           - Defensive Programming: Validate inputs, handle errors gracefully
           - Explicit State Management: Clear state transitions and history
]]

--- ======= LOCALIZE =======
--Addon
local _, ns = ...
--- @class NAG
local NAG = LibStub("AceAddon-3.0"):GetAddon("NAG")
local L = LibStub("AceLocale-3.0"):GetLocale("NAG", true)

-- Constants
local CONSTANTS = {
    MAX_RUNES = 6,                 -- Maximum number of runes
    RUNE_TYPE = {                  -- Rune types
        BLOOD = 1,
        FROST = 2,
        UNHOLY = 3,
        DEATH = 4
    },
    STATE_CAPTURE = {
        PRE_CAST = 1,
        POST_CAST = 2,
        INTERVAL = 3,
        COMBAT_START = 4,
        COMBAT_END = 5
    },
    MAX_HISTORY_SIZE = 20,        -- Maximum number of state snapshots to keep
    VERSION = 2                    -- Module data version for migrations
}

-- Default settings with explicit organization
local defaults = {
    global = {
        version = CONSTANTS.VERSION,
        debugMode = false,
        autoSave = true,
        lastCompilation = 0,
        maxHistoryEntries = 100,
        performanceMode = "balanced" -- options: minimal, balanced, full
    },
    char = {
        enabled = true,
        trackingEnabled = true,
        predictionEnabled = true,
        spellOptions = {}
    }
}

---@class SpellLearner: ModuleBase
local SpellLearner = NAG:CreateModule("SpellLearner", defaults, {
    optionsCategory = ns.MODULE_CATEGORIES.FEATURE,
    optionsOrder = 21,
    childGroups = "tree",
})

-- Table pool for efficient memory usage
SpellLearner.tablePool = {
    available = {},
    inUse = 0,
    totalCreated = 0
}

-- Module interface table for public API
SpellLearner.API = {}

-- Event management helpers
SpellLearner.events = {}

do -- Ace3 lifecycle methods
    --- Initialize the module
    function SpellLearner:ModuleInitialize()
        self:Info("Initializing SpellLearner")
        
        -- Initialize StateTracker (formerly StateManager)
        self.stateTracker = NAG:GetModule("SpellLearnerStateManager")
        if not self.stateTracker then
            self:Error("Failed to initialize StateTracker!")
            return
        end
        
        -- Initialize SpellAnalyzer (new module per rework plan)
        self.spellAnalyzer = NAG:GetModule("SpellAnalyzer") 
        if not self.spellAnalyzer then
            self:Debug("SpellAnalyzer not found, using legacy analysis")
            -- Fallback to integrated analysis if module not available
        end
        
        -- Initialize PredictionEngine
        self.predictionEngine = NAG:GetModule("PredictionEngine")
        if not self.predictionEngine then
            self:Error("Failed to initialize PredictionEngine!")
            return
        end
        
        -- Initialize table pool for memory efficiency
        self:InitializeTablePool()
        
        -- Set up event handling
        self:SetupEventHandling()
        
        -- Register slash commands
        self:RegisterSlashCommands()
        
        -- Initialize module state
        self.state = self:AcquireTable()
        self.state.initialized = true
        self.state.moduleVersion = CONSTANTS.VERSION
        
        -- Data migration if needed
        if self:GetGlobal().version < CONSTANTS.VERSION then
            self:MigrateData(self:GetGlobal().version)
            self:GetGlobal().version = CONSTANTS.VERSION
        end
        
        self:Debug("SpellLearner module initialization complete")
    end

    --- Enable the module
    function SpellLearner:ModuleEnable()
        self:Debug("Enabling SpellLearner")
        
        -- Enable StateTracker
        if self.stateTracker then
            self.stateTracker:Enable()
            self:Debug("StateTracker enabled")
        end
        
        -- Enable SpellAnalyzer if available
        if self.spellAnalyzer then
            self.spellAnalyzer:Enable()
            self:Debug("SpellAnalyzer enabled")
        end
        
        -- Enable PredictionEngine for suggestions
        if self.predictionEngine and self:GetChar().predictionEnabled then
            self.predictionEngine:Enable()
            self:Debug("PredictionEngine enabled")
        end
        
        -- Schedule initial data processing
        if GetTime() - (self:GetGlobal().lastCompilation or 0) > 300 then -- 5 minutes
            C_Timer.After(5, function() 
                if self.predictionEngine and self.predictionEngine:IsEnabled() then
                    self:Debug("Running initial spell data compilation")
                    self.predictionEngine:CompileSpellData()
                    self:GetGlobal().lastCompilation = GetTime()
                end
            end)
        end
        
        -- Register for class-specific tracking
        local _, playerClass = UnitClass("player")
        if playerClass == "DEATHKNIGHT" then
            self:SetupDeathKnightTracking()
        end
    end

    --- Disable the module
    function SpellLearner:ModuleDisable()
        self:Debug("Disabling SpellLearner")
        
        -- Disable StateTracker
        if self.stateTracker then
            self.stateTracker:Disable()
            self:Debug("StateTracker disabled")
        end
        
        -- Disable SpellAnalyzer if available
        if self.spellAnalyzer then
            self.spellAnalyzer:Disable()
            self:Debug("SpellAnalyzer disabled")
        end
        
        -- Disable PredictionEngine
        if self.predictionEngine then
            self.predictionEngine:Disable()
            self:Debug("PredictionEngine disabled")
        end
        
        -- Unregister events
        self:UnregisterAllEvents()
        
        -- Save any pending data
        self:SavePendingData()
        
        -- Clean up tables
        self:ReleaseAllTables()
    end
end

--- Gets the options table for module settings
--- @return table The options table for AceConfig
function SpellLearner:GetOptions()
    return {
        general = {
            type = "group",
            name = L["general"],
            order = 1,
            args = {
                debugMode = {
                    type = "toggle",
                    name = L["debugMode"],
                    desc = L["debugModeDesc"],
                    order = 1,
                    get = function() return self:GetGlobal().debugMode end,
                    set = function(_, value)
                        self:GetGlobal().debugMode = value
                        -- Also set debug mode for StateManager
                        if self.stateTracker then
                            self.stateTracker:GetGlobal().debugMode = value
                        end
                        LibStub("AceConfigRegistry-3.0"):NotifyChange("NAG")
                    end,
                },
                enabled = {
                    type = "toggle",
                    name = L["enabled"],
                    desc = L["enabledDesc"],
                    order = 2,
                    get = function() return self:GetChar().enabled end,
                    set = function(_, value)
                        self:GetChar().enabled = value
                        if value then
                            self:Enable()
                        else
                            self:Disable()
                        end
                        LibStub("AceConfigRegistry-3.0"):NotifyChange("NAG")
                    end,
                },
            }
        }
    }
end

-- Make module available globally through NAG
ns.SpellLearner = SpellLearner 

--- Initialize the table pooling system for efficient memory management
function SpellLearner:InitializeTablePool()
    -- Set up table pool for memory efficiency
    self.tablePool = {
        available = {},
        inUse = 0,
        totalCreated = 0,
        maxPoolSize = 100
    }
    
    -- Method to get a clean table from the pool
    function self:AcquireTable()
        local tbl
        
        if #self.tablePool.available > 0 then
            -- Reuse an existing table
            tbl = tremove(self.tablePool.available)
            -- Clear any existing data
            wipe(tbl)
        else
            -- Create a new table
            tbl = {}
            self.tablePool.totalCreated = self.tablePool.totalCreated + 1
        end
        
        self.tablePool.inUse = self.tablePool.inUse + 1
        return tbl
    end
    
    -- Method to return a table to the pool
    function self:ReleaseTable(tbl)
        if type(tbl) ~= "table" then
            return false
        end
        
        wipe(tbl)
        
        -- Only store up to our max pool size
        if #self.tablePool.available < self.tablePool.maxPoolSize then
            tinsert(self.tablePool.available, tbl)
        end
        
        self.tablePool.inUse = self.tablePool.inUse - 1
        return true
    end
    
    -- Method to release all tables
    function self:ReleaseAllTables()
        -- In a production environment, we'd iterate through tracked tables
        -- For this rework, we'll rely on the tables going out of scope
        -- Keep this method as a placeholder for future implementation
        self.tablePool.inUse = 0
    end
    
    self:Debug(format("Table pool initialized (Max size: %d)", self.tablePool.maxPoolSize))
end

--- Set up event handling system
function SpellLearner:SetupEventHandling()
    -- Register core module events
    self:RegisterEvent("PLAYER_ENTERING_WORLD", "OnPlayerEnteringWorld")
    self:RegisterEvent("PLAYER_SPECIALIZATION_CHANGED", "OnSpecializationChanged")
    self:RegisterEvent("UNIT_SPELLCAST_SUCCEEDED", "OnSpellCastSucceeded")
    
    -- Set up event delegation to submodules
    self.events.delegationMap = {
        PLAYER_ENTERING_WORLD = { "stateTracker", "predictionEngine" },
        PLAYER_SPECIALIZATION_CHANGED = { "stateTracker", "predictionEngine" },
        COMBAT_LOG_EVENT_UNFILTERED = { "stateTracker" },
        UNIT_SPELLCAST_SUCCEEDED = { "stateTracker" },
        PLAYER_REGEN_DISABLED = { "stateTracker", "predictionEngine" },
        PLAYER_REGEN_ENABLED = { "stateTracker" }
    }
    
    -- Register delegated events
    for event, modules in pairs(self.events.delegationMap) do
        self:RegisterEvent(event, "DelegateEvent")
    end
    
    self:Debug("Event handling system initialized")
end

--- Register all slash commands
function SpellLearner:RegisterSlashCommands()
    -- Command for clearing data
    self:RegisterChatCommand("nagclear", function(input)
        if input == "confirm" or input == "p" then
            self:ClearLearnedData(input)
        else
            self:Debug("To clear processed data only, use: /nagclear p")
            self:Debug("To clear all learned data, use: /nagclear confirm")
            self:Debug("WARNING: Using 'confirm' will erase all learned spell data!")
        end
    end)
    
    -- Command for processing data
    self:RegisterChatCommand("nagprocess", function(input)
        if not self.predictionEngine then
            self:Error("PredictionEngine not available!")
            return
        end

        if input and input ~= "" then
            -- Try to convert input to spell ID
            local spellID = tonumber(input)
            if spellID then
                self:Debug(format("Processing data only for spell %d (%s)", 
                    spellID, GetSpellInfo(spellID) or "Unknown"))
                self.predictionEngine:ForceProcessData(spellID)
            else
                self:Debug("Invalid spell ID provided. Usage: /nagprocess [spellID]")
            end
        else
            -- Process all spells as before
            self.predictionEngine:ForceProcessData()
        end
    end)
    
    -- Command for Death Knight rune analysis
    self:RegisterChatCommand("nagrunes", function(input)
        local _, class = UnitClass("player")
        if class ~= "DEATHKNIGHT" then
            self:Debug("This command is only available for Death Knights.")
            return
        end
        
        -- Call class-specific analysis
        self:AnalyzeDeathKnightRuneUsage(input)
    end)
    
    -- Command for data inspection
    self:RegisterChatCommand("nagdata", InspectSpellData)
    
    -- Command for advanced processing
    self:RegisterChatCommand("nagdiagnostic", ProcessSpellData)
    
    -- Command for force data synchronization
    self:RegisterChatCommand("nagsync", ForceDataSync)
    
    self:Debug("Slash commands registered")
end

--- Setup Death Knight specific tracking
function SpellLearner:SetupDeathKnightTracking()
    -- Don't double-register
    if self.state.dkTrackingEnabled then
        return
    end
    
    -- Register for rune events
    self:RegisterEvent("RUNE_POWER_UPDATE", "OnRunePowerUpdate")
    self:RegisterEvent("RUNE_TYPE_UPDATE", "OnRuneTypeUpdate")
    
    -- Initialize rune tracking state
    self.state.runeState = self:AcquireTable()
    for i = 1, CONSTANTS.MAX_RUNES do
        self.state.runeState[i] = {
            type = 0,
            startTime = 0,
            duration = 0,
            runeReady = true
        }
    end
    
    -- Track global rune statistics
    self.state.runeStats = self:AcquireTable()
    self.state.runeStats.usedCount = {
        [CONSTANTS.RUNE_TYPE.BLOOD] = 0,
        [CONSTANTS.RUNE_TYPE.FROST] = 0,
        [CONSTANTS.RUNE_TYPE.UNHOLY] = 0,
        [CONSTANTS.RUNE_TYPE.DEATH] = 0
    }
    
    self.state.dkTrackingEnabled = true
    self:Debug("Death Knight rune tracking enabled")
end

--- Handle delegation of events to submodules
function SpellLearner:DelegateEvent(event, ...)
    if not self.events.delegationMap[event] then 
        return
    end
    
    -- Pass the event to each registered submodule
    for _, moduleName in ipairs(self.events.delegationMap[event]) do
        local module = self[moduleName]
        if module and module:IsEnabled() then
            local handler = module["On" .. event]
            if type(handler) == "function" then
                handler(module, ...)
            elseif module.ProcessEvent then
                module:ProcessEvent(event, ...)
            end
        end
    end
end

--- Event handler for PLAYER_ENTERING_WORLD
function SpellLearner:OnPlayerEnteringWorld()
    self:Debug("Player entered world, initializing state")
    
    -- Check if we need to migrate data
    if self:GetGlobal().version < CONSTANTS.VERSION then
        self:MigrateData(self:GetGlobal().version)
    end
    
    -- Initialize class-specific tracking
    local _, playerClass = UnitClass("player")
    if playerClass == "DEATHKNIGHT" and not self.state.dkTrackingEnabled then
        self:SetupDeathKnightTracking()
    end
    
    -- Queue data compilation if needed
    if GetTime() - (self:GetGlobal().lastCompilation or 0) > 3600 then -- 1 hour
        C_Timer.After(10, function()
            if self.predictionEngine and self.predictionEngine:IsEnabled() then
                self:Debug("Running scheduled spell data compilation")
                self.predictionEngine:CompileSpellData()
                self:GetGlobal().lastCompilation = GetTime()
            end
        end)
    end
end

--- Event handler for PLAYER_SPECIALIZATION_CHANGED
function SpellLearner:OnSpecializationChanged()
    self:Debug("Player specialization changed, updating state")
    
    -- Clear current state
    if self.state.currentState then
        wipe(self.state.currentState)
    end
    
    -- Schedule recompilation of relevant data
    C_Timer.After(2, function()
        if self.predictionEngine and self.predictionEngine:IsEnabled() then
            self:Debug("Recompiling spell data after spec change")
            self.predictionEngine:CompileSpellData()
        end
    end)
end

--- Save any pending data to SavedVariables
function SpellLearner:SavePendingData()
    self:Debug("Saving pending data to SavedVariables")
    
    if self.stateTracker and self.stateTracker.SaveSpellData then
        self.stateTracker:SaveSpellData()
    end
    
    if self.predictionEngine and self.predictionEngine.SaveCompiledData then
        self.predictionEngine:SaveCompiledData()
    end
    
    -- Update compilation timestamp
    self:GetGlobal().lastCompilation = GetTime()
end

--- Data migration function for versioning
function SpellLearner:MigrateData(fromVersion)
    self:Debug(format("Migrating data from version %d to %d", fromVersion, CONSTANTS.VERSION))
    
    if fromVersion < 2 then
        -- Version 1 to 2 migration
        -- Convert old StateManager data format to new StateTracker format
        if self.stateTracker and self.stateTracker.MigrateData then
            self.stateTracker:MigrateData(fromVersion)
        end
        
        if self.predictionEngine and self.predictionEngine.MigrateData then
            self.predictionEngine:MigrateData(fromVersion)
        end
    end
    
    -- Update version
    self:GetGlobal().version = CONSTANTS.VERSION
end

--- Clear all learned data
-- @param clearType string Optional - 'p' for processed data only, 'confirm' for full clear
function SpellLearner:ClearLearnedData(clearType)
    if clearType == "p" then
        -- Clear only the processed/learned data
        if self:GetChar().compiled then
            wipe(self:GetChar().compiled)
        end
        
        -- Clear processed history
        if self:GetChar().processedHistory then
            wipe(self:GetChar().processedHistory)
        end
        
        -- Clear spell effects (learned relationships)
        if self.stateTracker and self.stateTracker.state then
            -- Clear core tracking structures
            self.stateTracker.state.spellEffects = {}
            self.stateTracker.state.activeBuffs = {}
            
            -- Clear new state tracking data
            self.stateTracker.state.pendingCasts = {}
            if self.stateTracker.state.stateHistory then
                wipe(self.stateTracker.state.stateHistory)
            end
            
            -- Clear specialized tracking caches
            if self.stateTracker.state.dotCache then
                wipe(self.stateTracker.state.dotCache)
            end
            
            -- Clear aura caches
            if self.stateTracker.auraCache then
                wipe(self.stateTracker.auraCache.player)
                wipe(self.stateTracker.auraCache.target)
            end
            
            -- Debug output for clearing
            self:Debug("Cleared state tracker tracking data")
        end
        
        -- Clear PredictionEngine processed data
        if self.predictionEngine then
            -- Clear compiled knowledge
            if self.predictionEngine:GetChar().compiled then
                wipe(self.predictionEngine:GetChar().compiled)
            end
            
            -- Clear processed history
            if self.predictionEngine:GetChar().processedHistory then
                wipe(self.predictionEngine:GetChar().processedHistory)
            end
            
            -- Clear outlier statistics
            if self.predictionEngine:GetChar().outlierStats then
                wipe(self.predictionEngine:GetChar().outlierStats)
            end
            
            -- Reset last processed time
            self.predictionEngine:GetChar().lastProcessedTime = 0
            
            -- Clear any predictions
            if self.predictionEngine.state and self.predictionEngine.state.predictions then
                wipe(self.predictionEngine.state.predictions)
            end
            
            -- Clear additional analysis caches
            if self.predictionEngine.state then
                if self.predictionEngine.state.runeAnalysis then
                    wipe(self.predictionEngine.state.runeAnalysis)
                end
                
                if self.predictionEngine.state.resourceAnalysis then
                    wipe(self.predictionEngine.state.resourceAnalysis)
                end
                
                if self.predictionEngine.state.dotAnalysis then
                    wipe(self.predictionEngine.state.dotAnalysis)
                end
            end
        end
        
        self:Debug("Processed data has been cleared")
        self:Debug("Raw spell cast records have been preserved")
        self:Debug("Use /nagprocess to reprocess the existing cast records")
        
    elseif clearType == "confirm" then
        -- First clear all processed data
        self:ClearLearnedData("p")
        
        -- Then clear raw data
        if self.stateTracker and self.stateTracker.db.global.spellChanges then
            wipe(self.stateTracker.db.global.spellChanges)
        end
        
        self:Debug("All data has been cleared")
        self:Debug("Use /nagprocess to start learning from new cast records")
    else
        self:Debug("To clear processed data only, use: /nagclear p")
        self:Debug("To clear all learned data, use: /nagclear confirm")
        self:Debug("WARNING: Using 'confirm' will erase all learned spell data!")
    end
end

--- Analyze Death Knight rune usage across all spells
-- @param spellFilter string Optional spell name filter
function SpellLearner:AnalyzeDeathKnightRuneUsage(spellFilter)
    if not self.stateTracker or not self.stateTracker.db.global.spellChanges then
        self:Debug("No spell data available for analysis")
        return
    end
    
    local spellFilter = strlower(spellFilter or "")
    local allSpells = {}
    local totalCasts = 0
    local totalRunesSpent = {
        [CONSTANTS.RUNE_TYPE.BLOOD] = 0,
        [CONSTANTS.RUNE_TYPE.FROST] = 0,
        [CONSTANTS.RUNE_TYPE.UNHOLY] = 0,
        [CONSTANTS.RUNE_TYPE.DEATH] = 0,
        total = 0
    }
    
    -- Collect spell data
    for spellID, entries in pairs(self.stateTracker.db.global.spellChanges) do
        local spellName = GetSpellInfo(spellID) or "Unknown"
        
        -- Apply filter if provided
        if spellFilter == "" or strlower(spellName):find(spellFilter) then
            local spellData = {
                id = spellID,
                name = spellName,
                casts = #entries,
                runePatterns = {},
                runesUsed = {
                    [CONSTANTS.RUNE_TYPE.BLOOD] = 0,
                    [CONSTANTS.RUNE_TYPE.FROST] = 0,
                    [CONSTANTS.RUNE_TYPE.UNHOLY] = 0,
                    [CONSTANTS.RUNE_TYPE.DEATH] = 0,
                    total = 0
                },
                averageRunesPerCast = 0,
                mostCommonPattern = ""
            }
            
            -- Analyze entries
            for _, entry in ipairs(entries) do
                totalCasts = totalCasts + 1
                
                -- Check for rune usage
                if entry.runeUsage then
                    -- Count runes by type
                    for runeType, count in pairs(entry.runeUsage) do
                        spellData.runesUsed[runeType] = spellData.runesUsed[runeType] + count
                        spellData.runesUsed.total = spellData.runesUsed.total + count
                        
                        -- Update global totals
                        totalRunesSpent[runeType] = totalRunesSpent[runeType] + count
                        totalRunesSpent.total = totalRunesSpent.total + count
                    end
                end
                
                -- Track patterns
                if entry.runePattern then
                    spellData.runePatterns[entry.runePattern] = (spellData.runePatterns[entry.runePattern] or 0) + 1
                end
            end
            
            -- Calculate average runes per cast
            if spellData.casts > 0 then
                spellData.averageRunesPerCast = spellData.runesUsed.total / spellData.casts
            end
            
            -- Find most common pattern
            local highestCount = 0
            for pattern, count in pairs(spellData.runePatterns) do
                if count > highestCount then
                    highestCount = count
                    spellData.mostCommonPattern = pattern
                end
            end
            
            -- Only include spells that actually use runes
            if spellData.runesUsed.total > 0 then
                table.insert(allSpells, spellData)
            end
        end
    end
    
    -- Skip processing if no data
    if #allSpells == 0 then
        self:Debug("No rune usage data found" .. (spellFilter ~= "" and " for filter: " .. spellFilter or ""))
        return
    end
    
    -- Sort spells by total runes used
    table.sort(allSpells, function(a, b) return a.runesUsed.total > b.runesUsed.total end)
    
    -- Display results
    self:Debug("|cFF00FFFF===== Death Knight Rune Usage Analysis " .. 
        (spellFilter ~= "" and "for '" .. spellFilter .. "'" or "") .. " =====|r")
    
    -- Display overall statistics
    self:Debug("\n|cFFFFFF00Overall Statistics:|r")
    self:Debug(format("Total casts analyzed: %d", totalCasts))
    self:Debug(format("Total runes spent: %d", totalRunesSpent.total))
    self:Debug(format("  Blood: %d (%.1f%%)", 
        totalRunesSpent[CONSTANTS.RUNE_TYPE.BLOOD],
        totalRunesSpent.total > 0 and (totalRunesSpent[CONSTANTS.RUNE_TYPE.BLOOD] / totalRunesSpent.total * 100) or 0))
    self:Debug(format("  Frost: %d (%.1f%%)", 
        totalRunesSpent[CONSTANTS.RUNE_TYPE.FROST],
        totalRunesSpent.total > 0 and (totalRunesSpent[CONSTANTS.RUNE_TYPE.FROST] / totalRunesSpent.total * 100) or 0))
    self:Debug(format("  Unholy: %d (%.1f%%)", 
        totalRunesSpent[CONSTANTS.RUNE_TYPE.UNHOLY],
        totalRunesSpent.total > 0 and (totalRunesSpent[CONSTANTS.RUNE_TYPE.UNHOLY] / totalRunesSpent.total * 100) or 0))
    self:Debug(format("  Death: %d (%.1f%%)", 
        totalRunesSpent[CONSTANTS.RUNE_TYPE.DEATH],
        totalRunesSpent.total > 0 and (totalRunesSpent[CONSTANTS.RUNE_TYPE.DEATH] / totalRunesSpent.total * 100) or 0))
    
    -- Display spell-specific statistics
    self:Debug("\n|cFFFFFF00Spell Breakdown:|r")
    for i, spell in ipairs(allSpells) do
        if i > 10 and spellFilter == "" then
            self:Debug(format("... and %d more spells (use a filter to see more details)", #allSpells - 10))
            break
        end
        
        self:Debug(format("\n%d. %s (ID: %d)", i, spell.name, spell.id))
        self:Debug(format("   Casts: %d, Total Runes: %d (%.1f per cast)",
            spell.casts, spell.runesUsed.total, spell.averageRunesPerCast))
        
        -- Only show pattern if we have one
        if spell.mostCommonPattern ~= "" then
            self:Debug(format("   Most common pattern: %s", spell.mostCommonPattern))
        end
        
        -- Display rune distribution
        self:Debug(format("   Rune distribution: B:%d, F:%d, U:%d, D:%d",
            spell.runesUsed[CONSTANTS.RUNE_TYPE.BLOOD],
            spell.runesUsed[CONSTANTS.RUNE_TYPE.FROST],
            spell.runesUsed[CONSTANTS.RUNE_TYPE.UNHOLY],
            spell.runesUsed[CONSTANTS.RUNE_TYPE.DEATH]))
    end
    
    -- Add helpful tips at the end
    self:Debug("\n|cFFFFFF00Tips:|r")
    self:Debug("- Use /nagrunes <spell name> to filter for specific spells")
    self:Debug("- Death runes can replace any other rune type")
    self:Debug("- Use pattern information to optimize your rotation")
end

-- Add a command to inspect recorded spell data
local function InspectSpellData(input)
    local spellID = input and tonumber(input:match("^(%d+)"))
    local PredictionEngine = NAG:GetModule("PredictionEngine")
    local StateTracker = NAG:GetModule("SpellLearnerStateManager")
    
    if not PredictionEngine or not StateTracker then
        NAG:Print("SpellLearner modules are not available")
        return
    end
    
    if spellID then
        -- Show detailed data for specific spell
        local spellName = GetSpellInfo(spellID) or "Unknown"
        NAG:Print(format("Data for %s (ID: %d):", spellName, spellID))
        
        -- Check PredictionEngine data
        local spellData = PredictionEngine:GetChar().compiled and PredictionEngine:GetChar().compiled[spellID]
        if spellData then
            NAG:Print("  PredictionEngine data: Available")
            
            -- Count contexts
            local contextCount = 0
            for context in pairs(spellData) do
                contextCount = contextCount + 1
            end
            NAG:Print(format("  Contexts: %d", contextCount))
            
            -- Show sample context
            local defaultContext = spellData["default"]
            if defaultContext then
                NAG:Print("  Default context includes:")
                if defaultContext.cost then
                    NAG:Print("    Resource costs")
                end
                if defaultContext.applies then
                    NAG:Print("    Buff applications")
                end
                if defaultContext.removes then
                    NAG:Print("    Buff removals")
                end
                if defaultContext.cooldown then
                    NAG:Print(format("    Cooldown: %.1f seconds", defaultContext.cooldown))
                end
            end
        else
            NAG:Print("  PredictionEngine data: None")
        end
        
        -- Check StateTracker data
        local effectData = StateTracker.state and StateTracker.state.spellEffects and StateTracker.state.spellEffects[spellID]
        if effectData then
            NAG:Print("  StateTracker data: Available")
            NAG:Print(format("  Total recorded casts: %d", effectData.totalCasts or 0))
            
            -- Resource changes
            if effectData.resourceChanges and next(effectData.resourceChanges) then
                NAG:Print("  Resource changes:")
                for resourceType, stats in pairs(effectData.resourceChanges) do
                    local avgChange = stats.count > 0 and (stats.total / stats.count) or 0
                    NAG:Print(format("    %s: Avg: %.1f, Min: %.1f, Max: %.1f", 
                        resourceType, avgChange, stats.min or 0, stats.max or 0))
                end
            end
            
            -- Buffs applied
            if effectData.buffsApplied and next(effectData.buffsApplied) then
                NAG:Print("  Buffs applied:")
                for buffID, count in pairs(effectData.buffsApplied) do
                    local buffName = GetSpellInfo(buffID) or buffID
                    NAG:Print(format("    %s: %d times", buffName, count))
                end
            end
        else
            NAG:Print("  StateTracker data: None")
        end
    else
        -- Show summary of all recorded spells
        NAG:Print("Recorded spell data summary:")
        
        -- Count spells in PredictionEngine
        local peCount = 0
        if PredictionEngine:GetChar().compiled then
            for spellID in pairs(PredictionEngine:GetChar().compiled) do
                if spellID > 0 then
                    peCount = peCount + 1
                end
            end
        end
        NAG:Print(format("  Spells in PredictionEngine: %d", peCount))
        
        -- Count spells in StateTracker
        local smCount = 0
        local validSpells = {}
        if StateTracker.state and StateTracker.state.spellEffects then
            for spellID, data in pairs(StateTracker.state.spellEffects) do
                if spellID > 0 and data.totalCasts and data.totalCasts > 0 then
                    smCount = smCount + 1
                    table.insert(validSpells, {id = spellID, casts = data.totalCasts or 0})
                end
            end
        end
        NAG:Print(format("  Spells in StateTracker: %d", smCount))
        
        -- Show top 5 most cast spells
        if #validSpells > 0 then
            table.sort(validSpells, function(a, b) return a.casts > b.casts end)
            
            NAG:Print("  Most used spells:")
            for i = 1, math.min(5, #validSpells) do
                local spell = validSpells[i]
                local spellName = GetSpellInfo(spell.id) or "Unknown"
                NAG:Print(format("    %s (ID: %d): %d casts", spellName, spell.id, spell.casts))
            end
        else
            NAG:Print("  No valid spells recorded yet. Try casting some spells.")
            NAG:Print("  Make sure your class is supported and tracking is enabled.")
        end
        
        NAG:Print("Use /nagdata <spellID> for detailed information about a specific spell")
    end
end

-- Add command to process spell data
local function ProcessSpellData(input)
    local PredictionEngine = NAG:GetModule("PredictionEngine")
    local StateTracker = NAG:GetModule("SpellLearnerStateManager")
    
    if not PredictionEngine or not StateTracker then
        NAG:Print("SpellLearner modules are not available")
        return
    end
    
    -- Enable debugging to see detailed output
    local enableDebug = input and input:find("debug")
    local oldDebug = NAG.debugEnabled
    if enableDebug then
        NAG.debugEnabled = true
    end
    
    NAG:Print("Beginning spell data processing...")
    
    -- Step 1: Validate data is being saved correctly
    NAG:Print("Step 1: Validating data storage...")
    local saveResult = StateTracker:VerifyDataSaving()
    NAG:Print(format("  Data storage validation: %s", saveResult and "PASSED" or "FAILED"))
    
    if not saveResult then
        NAG:Print("ERROR: Data storage validation failed. Processing aborted.")
        NAG.debugEnabled = oldDebug
        return
    end
    
    -- Step 2: Count recorded spells
    local spellCount = 0
    local totalCasts = 0
    local resourceUsageSpells = 0
    local buffApplyingSpells = 0
    local buffRemovingSpells = 0
    
    if StateTracker.state and StateTracker.state.spellEffects then
        for spellID, effectData in pairs(StateTracker.state.spellEffects) do
            spellCount = spellCount + 1
            totalCasts = totalCasts + (effectData.totalCasts or 0)
            
            -- Check resource usage
            if effectData.resourceChanges and next(effectData.resourceChanges) then
                resourceUsageSpells = resourceUsageSpells + 1
            end
            
            -- Check buff applications
            if effectData.buffsApplied and next(effectData.buffsApplied) then
                buffApplyingSpells = buffApplyingSpells + 1
            end
            
            -- Check buff removals
            if effectData.buffsRemoved and next(effectData.buffsRemoved) then
                buffRemovingSpells = buffRemovingSpells + 1
            end
        end
    end
    
    NAG:Print("Step 2: Analyzing recorded spells...")
    NAG:Print(format("  Spells recorded: %d", spellCount))
    NAG:Print(format("  Total spell casts: %d", totalCasts))
    NAG:Print(format("  Spells with resource changes: %d", resourceUsageSpells))
    NAG:Print(format("  Spells applying buffs: %d", buffApplyingSpells))
    NAG:Print(format("  Spells removing buffs: %d", buffRemovingSpells))
    
    if spellCount == 0 then
        NAG:Print("ERROR: No spells recorded. Processing aborted.")
        NAG.debugEnabled = oldDebug
        return
    end
    
    -- Step 3: Synchronize data with PredictionEngine
    NAG:Print("Step 3: Synchronizing with PredictionEngine...")
    local syncResult = PredictionEngine:ValidateStateTrackerIntegration()
    NAG:Print(format("  Data synchronization: %s", syncResult and "COMPLETE" or "FAILED"))
    
    if not syncResult then
        NAG:Print("ERROR: Data synchronization failed. Processing aborted.")
        NAG.debugEnabled = oldDebug
        return
    end
    
    -- Step 4: Analyze and optimize compiled data
    NAG:Print("Step 4: Optimizing prediction data...")
    
    -- Get compiled spells count
    local compiledCount = 0
    if PredictionEngine:GetChar().compiled then
        for _ in pairs(PredictionEngine:GetChar().compiled) do
            compiledCount = compiledCount + 1
        end
    end
    NAG:Print(format("  Compiled spells: %d", compiledCount))
    
    -- Get context count
    local contextCount = 0
    local defaultContextCount = 0
    if PredictionEngine:GetChar().compiled then
        for _, spellData in pairs(PredictionEngine:GetChar().compiled) do
            for context in pairs(spellData) do
                contextCount = contextCount + 1
                if context == "default" then
                    defaultContextCount = defaultContextCount + 1
                end
            end
        end
    end
    NAG:Print(format("  Total contexts: %d (including %d default contexts)", contextCount, defaultContextCount))
    
    -- Step 5: Validate prediction quality
    NAG:Print("Step 5: Validating prediction quality...")
    -- This would involve more complex logic to test predictions against actual data
    -- For now, just report that it's pending
    NAG:Print("  Prediction quality validation: PENDING")
    NAG:Print("  This feature requires more data collection.")
    
    -- Summary
    NAG:Print("Spell data processing complete!")
    NAG:Print(format("Processed %d spells with %d total casts", spellCount, totalCasts))
    NAG:Print("Use /nagdata to inspect individual spell data")
    
    -- Restore debug setting
    NAG.debugEnabled = oldDebug
end

-- Add command to force data synchronization
local function ForceDataSync(input)
    local PredictionEngine = NAG:GetModule("PredictionEngine")
    local StateTracker = NAG:GetModule("SpellLearnerStateManager")
    
    if not PredictionEngine or not StateTracker then
        NAG:Print("SpellLearner modules are not available")
        return
    end
    
    NAG:Print("Forcing synchronization of spell data...")
    
    -- Step 1: Save current state tracker data
    local saveResult = StateTracker:SaveSpellData()
    NAG:Print(format("  State data save: %s", saveResult and "SUCCESS" or "FAILED"))
    
    if not saveResult then
        NAG:Print("ERROR: Failed to save state data. Aborting sync.")
        return
    end
    
    -- Step 2: Count spells to sync
    local spellCount = 0
    local syncedCount = 0
    local failedCount = 0
    
    -- Process each spell in StateTracker
    if StateTracker.state and StateTracker.state.spellEffects then
        local spellList = {}
        
        -- Collect valid spells
        for spellID, data in pairs(StateTracker.state.spellEffects) do
            if type(spellID) == "number" and spellID > 0 and data.totalCasts and data.totalCasts > 0 then
                table.insert(spellList, spellID)
                spellCount = spellCount + 1
            end
        end
        
        -- Sort by cast count for more relevant spells first
        table.sort(spellList, function(a, b)
            local castsA = StateTracker.state.spellEffects[a] and StateTracker.state.spellEffects[a].totalCasts or 0
            local castsB = StateTracker.state.spellEffects[b] and StateTracker.state.spellEffects[b].totalCasts or 0
            return castsA > castsB
        end)
        
        -- Sync each spell
        for _, spellID in ipairs(spellList) do
            local spellName = GetSpellInfo(spellID) or "Unknown"
            local result = StateTracker:SyncWithPredictionEngine(spellID)
            
            if result then
                syncedCount = syncedCount + 1
            else
                failedCount = failedCount + 1
            end
            
            -- Print progress for every 5 spells
            if (syncedCount + failedCount) % 5 == 0 or (syncedCount + failedCount) == spellCount then
                NAG:Print(format("  Progress: %d/%d spells processed", syncedCount + failedCount, spellCount))
            end
        end
    end
    
    -- Step 3: Save PredictionEngine data
    local peResult = false
    if PredictionEngine.SaveCompiledData then
        peResult = PredictionEngine:SaveCompiledData()
    end
    
    NAG:Print(format("  PredictionEngine save: %s", peResult and "SUCCESS" or "FAILED"))
    
    -- Final summary
    NAG:Print(format("Synchronization complete: %d spells processed (%d succeeded, %d failed)", 
        spellCount, syncedCount, failedCount))
    
    -- Force a UI reload to apply changes
    if input and input:lower() == "reload" then
        NAG:Print("Reloading UI to apply changes...")
        C_Timer.After(1, function() ReloadUI() end)
    else
        NAG:Print("Type '/nagsyncall reload' to reload UI and apply changes")
    end
end

-- Register spell learner commands with the help system
local function RegisterHelp()
    -- Check if the help system is available
    if not NAG.RegisterHelpTopic then return end
    
    -- Register main spell learner help topic
    NAG:RegisterHelpTopic("spelllearner", {
        name = "Spell Learner",
        description = "Analyzes and learns from spell usage to improve rotation predictions",
        commands = {
            "nagdata", "nagverify", "nagprocess", "nagsync", "nagspells", "nagchanges", "nagrunes"
        }
    })
    
    -- Register individual command help
    NAG:RegisterHelpTopic("nagdata", {
        name = "/nagdata [spellID]",
        description = "Inspect learned spell data",
        details = "Without arguments, shows a summary of all recorded spells. With a spell ID, shows detailed information about that specific spell.",
        parent = "spelllearner"
    })
    
    NAG:RegisterHelpTopic("nagverify", {
        name = "/nagverify",
        description = "Verify that spell data is being saved correctly",
        details = "Tests the saved variables system to ensure spell data is preserved between sessions.",
        parent = "spelllearner"
    })
    
    NAG:RegisterHelpTopic("nagprocess", {
        name = "/nagprocess [debug]",
        description = "Process collected spell data to improve predictions",
        details = "Analyzes recorded spell data, synchronizes with the prediction system, and optimizes the prediction database. Add 'debug' to enable verbose output.",
        parent = "spelllearner"
    })
    
    NAG:RegisterHelpTopic("nagsync", {
        name = "/nagsync",
        description = "Synchronize data between the state tracker and prediction engine",
        details = "Ensures that learned spell effects are properly integrated into the prediction system.",
        parent = "spelllearner"
    })
    
    NAG:RegisterHelpTopic("nagspells", {
        name = "/nagspells",
        description = "Shows statistics about spell learning",
        details = "Displays information about spell usage frequency, effects, and other learned properties.",
        parent = "spelllearner"
    })
    
    NAG:RegisterHelpTopic("nagchanges", {
        name = "/nagchanges [spellID]",
        description = "Shows detailed state changes caused by spells",
        details = "Without arguments, shows a summary of all recorded state changes. With a spell ID, shows detailed information about that specific spell's effects.",
        parent = "spelllearner"
    })
    
    NAG:RegisterHelpTopic("nagrunes", {
        name = "/nagrunes",
        description = "Shows Death Knight rune usage analysis",
        details = "Displays information about rune usage patterns, helping optimize rune-based abilities.",
        parent = "spelllearner"
    })
end

-- Register help topics when the addon is loaded
if NAG.RegisterHelpTopic then
    RegisterHelp()
else
    -- If help system isn't loaded yet, hook into ADDON_LOADED
    local frame = CreateFrame("Frame")
    frame:RegisterEvent("ADDON_LOADED")
    frame:SetScript("OnEvent", function(self, event, addonName)
        if addonName == "NAG" and NAG.RegisterHelpTopic then
            RegisterHelp()
            self:UnregisterAllEvents()
        end
    end)
end

-- Add command to force data synchronization
local function ForceDataSync(input)
    local PredictionEngine = NAG:GetModule("PredictionEngine")
    local StateTracker = NAG:GetModule("SpellLearnerStateManager")
    
    if not PredictionEngine or not StateTracker then
        NAG:Print("SpellLearner modules are not available")
        return
    end
    
    NAG:Print("Forcing synchronization of spell data...")
    
    -- Step 1: Save current state tracker data
    local saveResult = StateTracker:SaveSpellData()
    NAG:Print(format("  State data save: %s", saveResult and "SUCCESS" or "FAILED"))
    
    if not saveResult then
        NAG:Print("ERROR: Failed to save state data. Aborting sync.")
        return
    end
    
    -- Step 2: Count spells to sync
    local spellCount = 0
    local syncedCount = 0
    local failedCount = 0
    
    -- Process each spell in StateTracker
    if StateTracker.state and StateTracker.state.spellEffects then
        local spellList = {}
        
        -- Collect valid spells
        for spellID, data in pairs(StateTracker.state.spellEffects) do
            if type(spellID) == "number" and spellID > 0 and data.totalCasts and data.totalCasts > 0 then
                table.insert(spellList, spellID)
                spellCount = spellCount + 1
            end
        end
        
        -- Sort by cast count for more relevant spells first
        table.sort(spellList, function(a, b)
            local castsA = StateTracker.state.spellEffects[a] and StateTracker.state.spellEffects[a].totalCasts or 0
            local castsB = StateTracker.state.spellEffects[b] and StateTracker.state.spellEffects[b].totalCasts or 0
            return castsA > castsB
        end)
        
        -- Sync each spell
        for _, spellID in ipairs(spellList) do
            local spellName = GetSpellInfo(spellID) or "Unknown"
            local result = StateTracker:SyncWithPredictionEngine(spellID)
            
            if result then
                syncedCount = syncedCount + 1
            else
                failedCount = failedCount + 1
            end
            
            -- Print progress for every 5 spells
            if (syncedCount + failedCount) % 5 == 0 or (syncedCount + failedCount) == spellCount then
                NAG:Print(format("  Progress: %d/%d spells processed", syncedCount + failedCount, spellCount))
            end
        end
    end
    
    -- Step 3: Save PredictionEngine data
    local peResult = false
    if PredictionEngine.SaveCompiledData then
        peResult = PredictionEngine:SaveCompiledData()
    end
    
    NAG:Print(format("  PredictionEngine save: %s", peResult and "SUCCESS" or "FAILED"))
    
    -- Final summary
    NAG:Print(format("Synchronization complete: %d spells processed (%d succeeded, %d failed)", 
        spellCount, syncedCount, failedCount))
    
    -- Force a UI reload to apply changes
    if input and input:lower() == "reload" then
        NAG:Print("Reloading UI to apply changes...")
        C_Timer.After(1, function() ReloadUI() end)
    else
        NAG:Print("Type '/nagsyncall reload' to reload UI and apply changes")
    end
end

-- Add /nagsyncall command
NAG:RegisterChatCommand("nagsyncall", ForceDataSync)

-- Initialize global settings in OnInitialize
function SpellLearner:OnInitialize()
    -- Get or create global saved variables
    self:GetGlobal().autoSave = self:GetGlobal().autoSave or true
    self:GetGlobal().debugMode = self:GetGlobal().debugMode or false
    self:GetGlobal().lastCompilation = self:GetGlobal().lastCompilation or 0
    
    -- Register slash commands
    self:RegisterChatCommand("naglearn", "HandleSpellLearnerCommands")
end

-- Handle module loading in OnEnable
function SpellLearner:OnEnable()
    -- Initialize SpellLearnerStateManager if not already
    local StateTracker = self:GetModule("SpellLearnerStateManager", true)
    if StateTracker and not StateTracker:IsEnabled() then
        StateTracker:Enable()
    end
    
    -- Initialize PredictionEngine if not already
    local PredictionEngine = self:GetModule("PredictionEngine", true)
    if PredictionEngine and not PredictionEngine:IsEnabled() then
        PredictionEngine:Enable()
    end
    
    -- Set up initial compilation if we haven't in a while
    if GetTime() - (self:GetGlobal().lastCompilation or 0) > 300 then -- 5 minutes
        C_Timer.After(5, function() -- Wait for other modules to initialize
            if PredictionEngine and PredictionEngine:IsEnabled() then
                PredictionEngine:CompileSpellData()
            end
        end)
    end
    
    self:Print("SpellLearner module enabled")
end

-- Handle command processing for the module
function SpellLearner:HandleSpellLearnerCommands(input)
    local command = input:trim():lower()
    
    if command == "help" then
        self:PrintHelp()
        return
    end
    
    -- Try to handle command in state tracker
    local StateTracker = self:GetModule("SpellLearnerStateManager", true)
    if StateTracker and StateTracker:IsEnabled() and StateTracker.ProcessCommand then
        if StateTracker:ProcessCommand(command) then
            return -- Command was handled by StateTracker
        end
    end
    
    -- Try to handle command in prediction engine
    local PredictionEngine = self:GetModule("PredictionEngine", true)
    if PredictionEngine and PredictionEngine:IsEnabled() and PredictionEngine.ProcessCommand then
        if PredictionEngine:ProcessCommand(command) then
            return -- Command was handled by PredictionEngine
        end
    end
    
    -- Handle global commands
    if command == "debug" then
        self:GetGlobal().debugMode = not self:GetGlobal().debugMode
        self:Print("Debug mode " .. (self:GetGlobal().debugMode and "enabled" or "disabled"))
    elseif command == "autosave" then
        self:GetGlobal().autoSave = not self:GetGlobal().autoSave
        self:Print("Auto save " .. (self:GetGlobal().autoSave and "enabled" or "disabled"))
    elseif command == "status" then
        self:PrintStatus()
    elseif command == "compile" then
        if PredictionEngine and PredictionEngine:IsEnabled() then
            PredictionEngine:CompileSpellData()
            self:Print("Spell data compilation completed")
        else
            self:Print("PredictionEngine not available")
        end
    else
        self:Print("Unknown command: " .. command)
        self:PrintHelp()
    end
end

-- Print help information
function SpellLearner:PrintHelp()
    self:Print("NAG Spell Learner Commands:")
    self:Print("  /naglearn help - Show this help")
    self:Print("  /naglearn debug - Toggle debug mode")
    self:Print("  /naglearn autosave - Toggle automatic data saving")
    self:Print("  /naglearn save - Force save learned data")
    self:Print("  /naglearn clear - Clear all learned data")
    self:Print("  /naglearn status - Show module status")
    self:Print("  /naglearn compile - Force compile learned data")
end

-- Print module status
function SpellLearner:PrintStatus()
    local StateTracker = self:GetModule("SpellLearnerStateManager", true)
    local PredictionEngine = self:GetModule("PredictionEngine", true)
    
    self:Print("SpellLearner Status:")
    self:Print("  Debug Mode: " .. (self:GetGlobal().debugMode and "Enabled" or "Disabled"))
    self:Print("  Auto Save: " .. (self:GetGlobal().autoSave and "Enabled" or "Disabled"))
    
    -- Show StateTracker status
    if StateTracker then
        local spellCount = 0
        if StateTracker:GetChar().spellData then
            for _, _ in pairs(StateTracker:GetChar().spellData) do
                spellCount = spellCount + 1
            end
        end
        self:Print("  Learned Spells: " .. spellCount)
    else
        self:Print("  StateTracker: Not available")
    end
    
    -- Show PredictionEngine status
    if PredictionEngine then
        local compiledCount = 0
        if PredictionEngine:GetChar().compiled then
            for _, _ in pairs(PredictionEngine:GetChar().compiled) do
                compiledCount = compiledCount + 1
            end
        end
        self:Print("  Compiled Spells: " .. compiledCount)
    else
        self:Print("  PredictionEngine: Not available")
    end
end

--- Event handler for UNIT_SPELLCAST_SUCCEEDED
function SpellLearner:OnSpellCastSucceeded(unitID, castGUID, spellID)
    -- Only track player casts
    if unitID ~= "player" then return end
    
    -- Skip tracking if not enabled
    if not self:GetChar().trackingEnabled then return end
    
    local _, class = UnitClass("player")
    
    -- Add specialized tracking for Death Knights
    if class == "DEATHKNIGHT" and self.state.dkTrackingEnabled then
        self:TrackDeathKnightRuneUsage(spellID)
    end
end

--- Event handler for RUNE_POWER_UPDATE
function SpellLearner:OnRunePowerUpdate(runeIndex, isEnergize)
    if not self.state.dkTrackingEnabled or not runeIndex then return end
    
    -- Record rune cooldown start or completion
    if runeIndex >= 1 and runeIndex <= CONSTANTS.MAX_RUNES then
        local startTime, duration, runeReady = GetRuneCooldown(runeIndex)
        
        -- Update our tracked state
        self.state.runeState[runeIndex].startTime = startTime or 0
        self.state.runeState[runeIndex].duration = duration or 0
        self.state.runeState[runeIndex].runeReady = runeReady or false
        
        -- If we have a pending cast, associate this rune with it
        if self.state.pendingCast then
            local now = GetTime()
            if now - (self.state.pendingCast.timestamp or 0) < 1.5 then -- Within 1.5s of cast
                -- This is likely a rune consumed by our pending cast
                if not self.state.pendingCast.runesUsed then
                    self.state.pendingCast.runesUsed = {}
                end
                
                -- Only track consumption, not regeneration
                if not isEnergize and not runeReady then
                    local runeType = self:GetRuneType(runeIndex)
                    self.state.pendingCast.runesUsed[runeIndex] = runeType
                    
                    -- Record pattern
                    self:UpdateRunePattern(self.state.pendingCast)
                end
            end
        end
    end
end

--- Event handler for RUNE_TYPE_UPDATE
function SpellLearner:OnRuneTypeUpdate(runeIndex, runeType)
    if not self.state.dkTrackingEnabled or not runeIndex then return end
    
    -- Update our rune type tracking
    if runeIndex >= 1 and runeIndex <= CONSTANTS.MAX_RUNES then
        self.state.runeState[runeIndex].type = runeType or 0
    end
end

--- Get the current rune type for a given rune index
-- @param runeIndex number The rune index to check
-- @return number The rune type (BLOOD, FROST, UNHOLY, DEATH)
function SpellLearner:GetRuneType(runeIndex)
    if not runeIndex or runeIndex < 1 or runeIndex > CONSTANTS.MAX_RUNES then
        return 0
    end
    
    -- Try to get it from our tracked state first
    if self.state.runeState and self.state.runeState[runeIndex] and self.state.runeState[runeIndex].type ~= 0 then
        return self.state.runeState[runeIndex].type
    end
    
    -- Fall back to calculating based on index (default rune layout)
    if runeIndex <= 2 then
        return CONSTANTS.RUNE_TYPE.BLOOD
    elseif runeIndex <= 4 then
        return CONSTANTS.RUNE_TYPE.FROST
    else
        return CONSTANTS.RUNE_TYPE.UNHOLY
    end
end

--- Track Death Knight rune usage for a spell cast
-- @param spellID number The ID of the spell that was cast
function SpellLearner:TrackDeathKnightRuneUsage(spellID)
    -- Skip if we don't have a valid spell ID
    if not spellID or spellID == 0 then return end
    
    -- Take a snapshot of current rune state
    local preRuneState = self:AcquireTable()
    for i = 1, CONSTANTS.MAX_RUNES do
        local startTime, duration, runeReady = GetRuneCooldown(i)
        preRuneState[i] = {
            type = self:GetRuneType(i),
            ready = runeReady or false,
            startTime = startTime or 0,
            duration = duration or 0
        }
    end
    
    -- Create a pending cast entry
    self.state.pendingCast = {
        spellID = spellID,
        timestamp = GetTime(),
        preRuneState = preRuneState,
        runesUsed = {},
        runePattern = ""
    }
    
    -- Schedule a check after GCD to finalize rune usage
    C_Timer.After(1.5, function()
        self:FinalizeRuneUsage(spellID)
    end)
end

--- Finalize rune usage analysis after a spell cast
-- @param spellID number The ID of the spell that was cast
function SpellLearner:FinalizeRuneUsage(spellID)
    -- Ensure we have a pending cast that matches
    if not self.state.pendingCast or self.state.pendingCast.spellID ~= spellID then
        return
    end
    
    local pendingCast = self.state.pendingCast
    self.state.pendingCast = nil -- Clear for next cast
    
    -- Count runes used by type
    local runeUsage = {
        [CONSTANTS.RUNE_TYPE.BLOOD] = 0,
        [CONSTANTS.RUNE_TYPE.FROST] = 0,
        [CONSTANTS.RUNE_TYPE.UNHOLY] = 0,
        [CONSTANTS.RUNE_TYPE.DEATH] = 0,
        total = 0
    }
    
    -- Process the runes we've tracked as used
    for runeIndex, runeType in pairs(pendingCast.runesUsed or {}) do
        runeUsage[runeType] = runeUsage[runeType] + 1
        runeUsage.total = runeUsage.total + 1
        
        -- Update global statistics
        self.state.runeStats.usedCount[runeType] = self.state.runeStats.usedCount[runeType] + 1
    end
    
    -- If we have a valid pattern, store the spell data
    if runeUsage.total > 0 then
        local spellData = {
            spellID = spellID,
            runeUsage = runeUsage,
            runePattern = pendingCast.runePattern or "",
            timestamp = pendingCast.timestamp
        }
        
        -- Record in state tracker for persistent storage
        if self.stateTracker and self.stateTracker.RecordSpellRuneUsage then
            self.stateTracker:RecordSpellRuneUsage(spellData)
        else
            -- Fallback if direct recording not available
            self:RecordRuneUsageLocally(spellData)
        end
    end
    
    -- Release table
    self:ReleaseTable(pendingCast.preRuneState)
end

--- Update the rune pattern string for a spell cast
-- @param pendingCast table The pending cast data to update
function SpellLearner:UpdateRunePattern(pendingCast)
    if not pendingCast or not pendingCast.runesUsed then return end
    
    -- Create a pattern string like "BBF" (Blood, Blood, Frost)
    local pattern = ""
    local sortedRunes = {}
    
    -- Convert to sortable format
    for runeIndex, runeType in pairs(pendingCast.runesUsed) do
        table.insert(sortedRunes, {index = runeIndex, type = runeType})
    end
    
    -- Sort by index
    table.sort(sortedRunes, function(a, b) return a.index < b.index end)
    
    -- Create pattern string
    for _, rune in ipairs(sortedRunes) do
        if rune.type == CONSTANTS.RUNE_TYPE.BLOOD then
            pattern = pattern .. "B"
        elseif rune.type == CONSTANTS.RUNE_TYPE.FROST then
            pattern = pattern .. "F"
        elseif rune.type == CONSTANTS.RUNE_TYPE.UNHOLY then
            pattern = pattern .. "U"
        elseif rune.type == CONSTANTS.RUNE_TYPE.DEATH then
            pattern = pattern .. "D"
        end
    end
    
    pendingCast.runePattern = pattern
end

--- Record rune usage data locally if StateTracker unavailable
-- @param spellData table The spell data to record
function SpellLearner:RecordRuneUsageLocally(spellData)
    if not spellData or not spellData.spellID then return end
    
    -- Ensure we have a place to store the data
    if not self:GetGlobal().runeUsageData then
        self:GetGlobal().runeUsageData = {}
    end
    
    -- Add this entry
    if not self:GetGlobal().runeUsageData[spellData.spellID] then
        self:GetGlobal().runeUsageData[spellData.spellID] = {}
    end
    
    -- Add to the list of entries for this spell
    table.insert(self:GetGlobal().runeUsageData[spellData.spellID], {
        runeUsage = spellData.runeUsage,
        runePattern = spellData.runePattern,
        timestamp = spellData.timestamp
    })
    
    -- Limit to 100 entries per spell to avoid excessive memory usage
    if #self:GetGlobal().runeUsageData[spellData.spellID] > 100 then
        table.remove(self:GetGlobal().runeUsageData[spellData.spellID], 1)
    end
end

--- ======= PUBLIC API =======
-- These functions form the public API for other modules to use

--- Get the learned costs and effects of a spell
-- @param spellID number The ID of the spell to query
-- @param context string Optional context for the query (default: "default")
-- @return table The learned data for the spell in the specified context
function SpellLearner.API:GetSpellData(spellID, context)
    -- Sanitize inputs
    spellID = tonumber(spellID)
    context = context or "default"
    
    if not spellID or spellID <= 0 then
        return nil
    end
    
    -- If we have a PredictionEngine, use its data first
    if self.predictionEngine and self.predictionEngine:IsEnabled() then
        local data = self.predictionEngine:GetSpellData(spellID, context)
        if data then
            return data
        end
    end
    
    -- Fall back to StateTracker data if needed
    if self.stateTracker and self.stateTracker:IsEnabled() then
        local data = self.stateTracker:GetSpellEffects(spellID)
        if data then
            -- Convert to compatible format
            local result = {
                id = spellID,
                context = context,
                cost = {},
                applies = {},
                removes = {}
            }
            
            -- Extract resource costs
            if data.resourceChanges then
                for resourceType, changes in pairs(data.resourceChanges) do
                    if changes.count > 0 then
                        -- Use negative values for costs
                        local avgChange = changes.total / changes.count
                        if avgChange < 0 then
                            result.cost[resourceType] = -avgChange
                        end
                    end
                end
            end
            
            -- Extract buff applications
            if data.buffsApplied then
                for buffID, count in pairs(data.buffsApplied) do
                    if count > 0 then
                        result.applies[buffID] = true
                    end
                end
            end
            
            -- Extract buff removals
            if data.buffsRemoved then
                for buffID, count in pairs(data.buffsRemoved) do
                    if count > 0 then
                        result.removes[buffID] = true
                    end
                end
            end
            
            return result
        end
    end
    
    return nil
end

--- Get the observed effect of a spell on a specific resource
-- @param spellID number The ID of the spell to query
-- @param resourceType string The resource type to query (e.g., "mana", "energy")
-- @return number, number Average cost of the resource, confidence level (0-1)
function SpellLearner.API:GetResourceCost(spellID, resourceType)
    -- Sanitize inputs
    spellID = tonumber(spellID)
    
    if not spellID or spellID <= 0 or not resourceType then
        return 0, 0
    end
    
    -- If we have a PredictionEngine, use its data first
    if self.predictionEngine and self.predictionEngine:IsEnabled() then
        return self.predictionEngine:GetResourceCost(spellID, resourceType)
    end
    
    -- Fall back to StateTracker data if needed
    if self.stateTracker and self.stateTracker:IsEnabled() then
        local data = self.stateTracker:GetSpellEffects(spellID)
        if data and data.resourceChanges and data.resourceChanges[resourceType] then
            local changes = data.resourceChanges[resourceType]
            if changes.count > 0 then
                local avgChange = changes.total / changes.count
                
                -- Calculate confidence based on sample size and variation
                local confidence = math.min(changes.count / 10, 1) -- Scale by sample size up to 10 samples
                if changes.max and changes.min and avgChange ~= 0 then
                    -- Reduce confidence if there's high variation
                    local variation = (changes.max - changes.min) / math.abs(avgChange)
                    confidence = confidence * (1 - math.min(variation / 2, 0.5))
                end
                
                -- Only return negative values as costs
                if avgChange < 0 then
                    return -avgChange, confidence
                end
            end
        end
    end
    
    return 0, 0
end

--- Get the rune cost pattern for a Death Knight ability
-- @param spellID number The ID of the spell to query
-- @return string, number The most common rune pattern, confidence level (0-1)
function SpellLearner.API:GetRunePattern(spellID)
    -- Sanitize input
    spellID = tonumber(spellID)
    
    if not spellID or spellID <= 0 then
        return "", 0
    end
    
    -- Check if we're even a Death Knight
    local _, class = UnitClass("player")
    if class ~= "DEATHKNIGHT" then
        return "", 0
    end
    
    local patternCounts = {}
    local totalSamples = 0
    local mostCommonPattern = ""
    local highestCount = 0
    
    -- First try to get data from StateTracker
    if self.stateTracker and self.stateTracker.db and self.stateTracker.db.global and 
       self.stateTracker.db.global.spellChanges and self.stateTracker.db.global.spellChanges[spellID] then
        
        local entries = self.stateTracker.db.global.spellChanges[spellID]
        
        -- Count pattern occurrences
        for _, entry in ipairs(entries) do
            if entry.runePattern and entry.runePattern ~= "" then
                patternCounts[entry.runePattern] = (patternCounts[entry.runePattern] or 0) + 1
                totalSamples = totalSamples + 1
                
                if patternCounts[entry.runePattern] > highestCount then
                    highestCount = patternCounts[entry.runePattern]
                    mostCommonPattern = entry.runePattern
                end
            end
        end
    end
    
    -- Fall back to locally stored data if needed
    if totalSamples == 0 and self:GetGlobal().runeUsageData and self:GetGlobal().runeUsageData[spellID] then
        local entries = self:GetGlobal().runeUsageData[spellID]
        
        -- Count pattern occurrences
        for _, entry in ipairs(entries) do
            if entry.runePattern and entry.runePattern ~= "" then
                patternCounts[entry.runePattern] = (patternCounts[entry.runePattern] or 0) + 1
                totalSamples = totalSamples + 1
                
                if patternCounts[entry.runePattern] > highestCount then
                    highestCount = patternCounts[entry.runePattern]
                    mostCommonPattern = entry.runePattern
                end
            end
        end
    end
    
    -- Calculate confidence
    local confidence = 0
    if totalSamples > 0 then
        confidence = math.min(highestCount / totalSamples, 1) * math.min(totalSamples / 5, 1)
    end
    
    return mostCommonPattern, confidence
end

--- Get the number of runes of each type used by a spell
-- @param spellID number The ID of the spell to query
-- @return table, number Table of rune counts by type, confidence level (0-1)
function SpellLearner.API:GetRuneCost(spellID)
    -- Sanitize input
    spellID = tonumber(spellID)
    
    if not spellID or spellID <= 0 then
        return {}, 0
    end
    
    -- Check if we're even a Death Knight
    local _, class = UnitClass("player")
    if class ~= "DEATHKNIGHT" then
        return {}, 0
    end
    
    -- Initialize results
    local runeCosts = {
        [CONSTANTS.RUNE_TYPE.BLOOD] = 0,
        [CONSTANTS.RUNE_TYPE.FROST] = 0,
        [CONSTANTS.RUNE_TYPE.UNHOLY] = 0,
        [CONSTANTS.RUNE_TYPE.DEATH] = 0,
        total = 0
    }
    
    local totalSamples = 0
    local sampleWithRunes = 0
    
    -- First try to get data from StateTracker
    if self.stateTracker and self.stateTracker.db and self.stateTracker.db.global and 
       self.stateTracker.db.global.spellChanges and self.stateTracker.db.global.spellChanges[spellID] then
        
        local entries = self.stateTracker.db.global.spellChanges[spellID]
        
        -- Aggregate rune usage
        for _, entry in ipairs(entries) do
            totalSamples = totalSamples + 1
            
            if entry.runeUsage then
                sampleWithRunes = sampleWithRunes + 1
                
                for runeType, count in pairs(entry.runeUsage) do
                    if runeType and count and count > 0 then
                        runeCosts[runeType] = runeCosts[runeType] + count
                        runeCosts.total = runeCosts.total + count
                    end
                end
            end
        end
    end
    
    -- Fall back to locally stored data if needed
    if totalSamples == 0 and self:GetGlobal().runeUsageData and self:GetGlobal().runeUsageData[spellID] then
        local entries = self:GetGlobal().runeUsageData[spellID]
        
        -- Aggregate rune usage
        for _, entry in ipairs(entries) do
            totalSamples = totalSamples + 1
            
            if entry.runeUsage then
                sampleWithRunes = sampleWithRunes + 1
                
                for runeType, count in pairs(entry.runeUsage) do
                    if runeType and count and count > 0 then
                        runeCosts[runeType] = runeCosts[runeType] + count
                        runeCosts.total = runeCosts.total + count
                    end
                end
            end
        end
    end
    
    -- Average the results
    if sampleWithRunes > 0 then
        for runeType in pairs(runeCosts) do
            if runeType ~= "total" then
                runeCosts[runeType] = runeCosts[runeType] / sampleWithRunes
            end
        end
        runeCosts.total = runeCosts.total / sampleWithRunes
    end
    
    -- Calculate confidence
    local confidence = 0
    if totalSamples > 0 then
        confidence = math.min(sampleWithRunes / totalSamples, 1) * math.min(totalSamples / 5, 1)
    end
    
    return runeCosts, confidence
end

--- Register a callback for spell learning events
-- @param callbackType string The type of event to register for
-- @param callbackFn function The function to call when the event occurs
-- @return number The ID of the registered callback (used for unregistering)
function SpellLearner.API:RegisterCallback(callbackType, callbackFn)
    if not callbackType or type(callbackFn) ~= "function" then
        return 0
    end
    
    -- Initialize callbacks table if needed
    if not self.callbacks then
        self.callbacks = {
            nextID = 1,
            byType = {},
            byID = {}
        }
    end
    
    -- Register the callback
    local callbackID = self.callbacks.nextID
    self.callbacks.nextID = self.callbacks.nextID + 1
    
    if not self.callbacks.byType[callbackType] then
        self.callbacks.byType[callbackType] = {}
    end
    
    self.callbacks.byType[callbackType][callbackID] = callbackFn
    self.callbacks.byID[callbackID] = {
        type = callbackType,
        fn = callbackFn
    }
    
    return callbackID
end

--- Unregister a previously registered callback
-- @param callbackID number The ID of the callback to unregister
-- @return boolean True if the callback was successfully unregistered
function SpellLearner.API:UnregisterCallback(callbackID)
    if not callbackID or not self.callbacks or not self.callbacks.byID[callbackID] then
        return false
    end
    
    local callbackData = self.callbacks.byID[callbackID]
    self.callbacks.byID[callbackID] = nil
    
    if self.callbacks.byType[callbackData.type] then
        self.callbacks.byType[callbackData.type][callbackID] = nil
    end
    
    return true
end

--- Trigger callbacks for a specific event type
-- @param callbackType string The type of event to trigger
-- @param ... any Additional arguments to pass to the callback
function SpellLearner:TriggerCallbacks(callbackType, ...)
    if not self.callbacks or not self.callbacks.byType or not self.callbacks.byType[callbackType] then
        return
    end
    
    for _, callbackFn in pairs(self.callbacks.byType[callbackType]) do
        if type(callbackFn) == "function" then
            -- Use pcall to prevent errors in callbacks from breaking the addon
            local success, error = pcall(callbackFn, ...)
            if not success then
                self:Debug("Error in callback: " .. (error or "unknown error"))
            end
        end
    end
end

-- Expose the API on the module
SpellLearner.GetSpellData = function(self, ...) return self.API:GetSpellData(...) end
SpellLearner.GetResourceCost = function(self, ...) return self.API:GetResourceCost(...) end
SpellLearner.GetRunePattern = function(self, ...) return self.API:GetRunePattern(...) end
SpellLearner.GetRuneCost = function(self, ...) return self.API:GetRuneCost(...) end
SpellLearner.RegisterCallback = function(self, ...) return self.API:RegisterCallback(...) end
SpellLearner.UnregisterCallback = function(self, ...) return self.API:UnregisterCallback(...) end 